#!/bin/sh
# -*- mode: Tcl; tab-width: 8; -*-
# the next line is a tcl comment \
exec undroidwish "$0" -sdlresizable ${1+"$@"}

# exec unwish "$0" -sdlresizable ${1+"$@"}
#exec sdl2wish8.6 "$0" -sdlresizable ${1+"$@"}

#
# Copyright (C) 2016 by Roger E Critchlow Jr, Cambridge, MA, USA.
# 
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
# 

#
# This is a reimplementation of gnome-mahjongg, my preferred time wasting
# solitaire on linux.  For many years I have been annoyed by aspects of
# gnome-mahjongg, but each attempt to deal with the code have been repelled
# by the density of the frameworks used to write the program.  I literally
# could not find the program in its source code, because most of the source
# code is somewhere else in a software framework.  So, I have rewritten 
# the program using Tcl, Tk, and Snit so that all of the source code will
# be apparent to anyone wishing to modify the program.
#
# I will provide only the barest introduction to Tcl, Tk, and Snit because
# you will need other resources if you really want to understand.  Start
# with the online manuals at https://www.tcl.tk/man/ and liberally apply
# google to your problems
#
# Tcl writes function calls in the form
#	func arg arg2
# the result of a function call is captured by square brackets 
#	[func arg arg2]
# variable references are written as
#	$variable
# variable assignment is performed by the set command
#	set variable {1 2 3}
# double quoted text is scanned for command and variable substitution
#	"substitutes $variable and [func arg arg2] in line"
# but curly brace quoted text
#	{does not evaluate $variable or [func arg arg2]}
# Memorizing https://www.tcl.tk/man/tcl8.6/TclCmd/Tcl.htm is a good plan.
#
# Tk uses Tcl to implement graphical user interfaces.  Originally a client 
# of the X11 windowing system on Unix, Tk now happily runs as a native client
# almost everywhere.  Tk user interface widgets are instances given names
#	canvas .name
# the instance name can then be used to set and retrieve configuratio options
#	.name configure -background blue
#	.name cget -background
# or to run methods
#	.name create image
# The manual pages for Tk and the widget-demo.tcl example script will give you
# an overview of the widgets implemented by Tk.  But Mahjong doesn't use much 
# of all that because it is entirely implemented in one Tk canvas widget.
#
# Snit uses Tcl to implement a Tk style object system.  Snit is distributed as
# part of Tcllib, a library implemented entirely in Tcl without use of extensions
# written in C or other high level languages.
#
set script [info script]
#puts "script $script"
if {[catch {file readlink $script} file]} { set file $script }
#puts "file $file"
set dir [file dirname $file]
#puts "dir $dir"
lappend auto_path /usr/share/tcltk/tcllib1.17 $dir

package require Tcl
package require Tk
package require snit

set ::usetkpath 0
if {$::usetkpath} {
    package require tkpath
}

snit::type mahjong::prefs {
    option -file prefs.tcl
    option -directory -default {} -readonly true
    constructor {args} {
	$self configure {*}$args
    }
    method resolve {file} {
	if {[file isdir [file join ~ .config]]} {
	    set options(-directory) [file join ~ .config mahjong]
	} elseif {[file isdir [file join ~ Library Preferences]]} {
	    set options(-directory) [file join ~ Library Preferences mahjong]
	} elseif {[file isdir [file join ~ {Applications Data}]]} {
	    set options(-directory) [file join ~ {Applications Data} mahjong]
	} else {
	    error "unable to find a preferences directory"
	}
	if { ! [file isdir $options(-directory)]} {
	    file mkdir $options(-directory)
	}
	return [file join $options(-directory) $file]
    }
    method save-prefs {array} {
	if {[catch {
	    set fp [open [$self resolve prefs.tcl] w]
	    puts $fp "array set prefs {"
	    foreach {name value} $array {
		puts $fp [list $name $value]
	    }
	    puts $fp "}"
	    close $fp
	} error]} {
	    puts "save-prefs: $error\n$::errorInfo"
	}
    }
    method load-prefs {} {
	# puts "enter load-prefs in mahjong::prefs"
	array set prefs {}
	if {[catch {
	    set fp [open [$self resolve prefs.tcl] r]
	    set data [read $fp]
	    close $fp
	    if {[string first {array set prefs} $data] != 0} {
		error "malformed prefs.tcl"
	    }
	    # puts "read prefs.tcl = {$data}"
	    eval $data
	} error]} {
	    # puts "error in load-prefs: $error\n$::errorInfo"
	}
	return [array get prefs]
    }
    method save-scores {list} {
	if {[catch {
	    set fp [open [$self resolve scores.tcl] w] 
	    puts $fp [join $list \n]
	    close $fp
	} error]} {
	    puts "$self save-scores {...} $error\n$::errorInfo"
	}
    }
    method load-scores {} {
	set list {}
	if {[catch {
	    set fp [open [$self resolve scores.tcl] r] 
	    set list [split [string trim [read $fp]] \n]
	    close $fp
	} error]} {
	    puts "$self save-scores {...} $error\n$::errorInfo"
	    set list {}
	}
	return $list
    }
}

snit::type mahjong::layout {
    option -verbose -default 1
    option -map -default {} -configuremethod Configure
    option -layout -readonly true
    option -slots -readonly true
    option -layers -readonly true
    option -rows -readonly true
    option -blocks -readonly true

    constructor {args} {
	if {$options(-verbose) > 5} { puts "$self configure $args" }
	$self configure {*}$args
    }

    # create the layout from a map
    method {Configure -map} {val} {
	if {$options(-verbose) > 5} { puts "$self configure -map $val" }
	set options(-map) $val
	set options(-layout) [dict create]
	set options(-slots) {}
	foreach layer $options(-map) {
	    $self expand-layout $layer
	}
	foreach slot $options(-slots) {
	    $self compute-x-adjacent $slot
	    $self compute-z-shadow $slot
	    #$self compute-left-and-right-rows $slot
	}
	foreach slot $options(-slots) {
	    $self compute-x-closure $slot
	    $self compute-row-closure $slot
	}

    }

    # maintaining slots in the layout
    # the options(-layout) dictionary maps xyz slots to properties
    method set {xyz tag val} { dict set options(-layout) $xyz $tag $val }
    method get {xyz tag} { return [dict get $options(-layout) $xyz $tag] }
    method exists {xyz tag} { return [dict exists $options(-layout) $xyz $tag] }
    method lappend {xyz tag args} { dict with options(-layout) $xyz { lappend $tag {*}$args } }

    # maintaining the primary slot in the layout
    # this is the only one that changes after the layout is setup
    method set-slot {slot val} { $self set $slot slot $val }
    method get-slot {slot} { return [$self get $slot slot] }
    method exists-slot {slot} { return [$self exists $slot slot] }
    method set-empty {slot} { $self set-slot $slot {} }
    method is-empty {slot} { return [expr {[$self get-slot $slot] eq {}}] }
    method is-filled {slot} { return [expr {[$self get-slot $slot] ne {}}]}
    method is-endcap {xyz} { return [$self get $xyz endcap] }
    method is-naked-endcap {xyz} { return [$self get $xyz naked-endcap] }

    proc slot-x {slot} { return [lindex $slot 0] }
    proc slot-y {slot} { return [lindex $slot 1] }
    proc slot-z {slot} { return [lindex $slot 2] }

    # get all of the slots in render order
    # ie, those which are obscured are drawn before those which obscure
    method get-slots {} { return $options(-slots) }
    # find the slots in a z layer in render order
    method layer-slots {z} { return [lmap slot [$self get-slots] {expr {($z == [slot-z $slot]) ? $slot : [continue]}}] }

    # expand the layout map description
    method expand-layout {layout {z 0}} {
	if {$options(-verbose) > 5} { puts "$self expand-layout $layout" }
	set tag [lindex $layout 0]
	array set l [lrange $layout 1 end]
	if {[info exists l(z)]} { set z $l(z) }
	switch $tag {
	    layer {
		foreach p $l(parts) { $self expand-layout $p $z }
	    }
	    tile {
		set row [list [$self add-tile $l(x) $l(y) $z]]
		$self add-row $row
		$self add-block $row
	    }
	    row {
		set row {}
		for {set x $l(right)} {$x >= $l(left)} {set x [expr {$x-1}]} {
		    lappend row [$self add-tile $x $l(y) $z]
		}
		$self add-row $row
		$self add-block $row
	    }
	    block {
		set block {}
		for {set y $l(top)} {$y <= $l(bottom)} {set y [expr {$y+1}]} {
		    set row {}
		    for {set x $l(right)} {$x >= $l(left)} {set x [expr {$x-1}]} {
			lappend row [$self add-tile $x $y $z]
		    }
		    $self add-row $row
		    lappend block {*}$row
		}
		$self add-block $block
	    }
	    default { error "what is $layout doing in the map?" }
	}
    }

    # add the list of slots in a row
    method add-row {row} { foreach slot $row { $self set $slot row $row } }
    # add the list of slots in a block
    method add-block {block} { foreach slot $block { $self set $slot block $block } }
    # mark two cells as x-adjacents, should be x-adjacent, need x-left-adjacent and x-right-adjacent, too
    method add-x-adjacent {xyz xnynzn} { $self add-symmetric x-adjacent $xyz $xnynzn }
    # record a symmetric relation
    method add-symmetric {relation slot1 slot2} {
	# puts "$self add-symmetric $relation {$slot1} {$slot2}a"
	if {[lsearch [$self get $slot1 $relation] $slot2] < 0} {
	    $self lappend $slot1 $relation $slot2
	}
	if {[lsearch [$self get $slot2 $relation] $slot1] < 0} {
	    $self lappend $slot2 $relation $slot1
	}
	# puts "$relation {$slot1} is [$self get $slot1 $relation]"
	# puts "$relation {$slot2} is [$self get $slot2 $relation]"
    }
    # an antisymmetric relation
    method add-left-adjacent {slot1 slot2} {
	if {$slot2 ni [$self get $slot1 left-adjacent]} { $self lappend $slot1 left-adjacent $slot2 }
	if {$slot1 ni [$self get $slot2 right-adjacent]} { $self lappend $slot2 right-adjacent $slot1 }
    }
    method add-right-adjacent {slot1 slot2} { $self add-left-adjacent $slot2 $slot1 }
	
    # add a new tile to the layout
    method add-tile {x y z} {
	# canonicalize the coordinates
	# trouble with x, y in double vs integer as dictionary keys
	set x [expr {double($x)}]
	set y [expr {double($y)}]
	set z [expr {int($z)}]
	if {$options(-verbose) > 5} { puts "add-tile $x $y $z" }
	set xyz [list $x $y $z]
	# initialize slot
	$self set-slot $xyz {}
	foreach {tag val} {
	    x-adjacent {}
	    x-closure {}
	    left-adjacent {}
	    right-adjacent {}
	    z-shadow {}
	    endcap 0
	    naked-endcap 0
	    triple-point 0
	} {
	    $self set $xyz $tag $val
	}
	lappend options(-slots) $xyz
	return $xyz
    }

    # compute the x-adjacent set of the tile
    method compute-x-adjacent {xyz} {
	foreach {x y z} $xyz break
	foreach dx {-1 1} {
	    set xn [expr {$x+$dx}]
	    foreach dy {-0.5 0 0.5} {
		set yn [expr {$y+$dy}]
		if { ! [$self exists-slot [list $xn $yn $z]]} continue
		set xnynzn [list $xn $yn $z]
		$self add-x-adjacent $xyz $xnynzn
		if {$xn-$x < 0} {
		    $self add-left-adjacent $xyz $xnynzn
		} else {
		    $self add-right-adjacent $xyz $xnynzn
		}
	    }
	}
	if {[llength [$self left-adjacent $xyz]] == 0 || 
	    [llength [$self right-adjacent $xyz]] == 0} {
	    $self set $xyz endcap 1
	    if { ! [$self is-covered-in-z $xyz]} {
		$self set $xyz naked-endcap 1
	    }
	}
	if {[llength [$self left-adjacent $xyz]] == 2} {
	    # make an llr triple point
	    set llr [list {*}[$self left-adjacent $xyz] $xyz]
	    foreach slot $llr t {l1 l2 r} {
		$self set $xyz triple-point 1
		$self set $xyz triple-point-llr [list $t {*}$llr]
	    }
	}
	if {[llength [$self right-adjacent $xyz]] == 2} {
	    # make an lrr triple point
	    set lrr [list $xyz {*}[$self right-adjacent $xyz]]
	    foreach slot $lrr t {l r1 r2} {
		$self set $xyz triple-point 1
		$self set $xyz triple-point-lrr [list $t {*}$lrr]
	    }
	}
    }
    method is-triple-point {xyz} { return [$self get $xyz triple-point] }
    method triple-point-eval {xyz} {
	if {[$self exists $xyz triple-point-llr]} {
	    foreach {t l1 l2 r} [$self get $xyz triple-point-llr] break
	    set cl1 [$self all-empty [$self left-closure $l1]]
	    set cl2 [$self all-empty [$self left-closure $l2]]
	    set cr [$self all-empty [$self right-closure $r]]
	    if {$cr} {
		if {$cl1 && [$self is-filled $l2]} {
		    return [expr {$t in {l1 r}}]
		} elseif {[$self is-filled $l1] && $cl2} {
		    return [expr {$t in {l2 r}}]
		}
	    }
	}
	if {[$self exists $xyz triple-point-lrr]} {
	    foreach {t l r1 r2} [$self get $xyz triple-point-lrr] break
	    set cl [$self all-empty [$self left-closure $l]]
	    set cr1 [$self all-empty [$self right-closure $r1]]
	    set cr2 [$self all-empty [$self right-closure $r2]]
	    if {$cl} {
		if {$cr1 && [$self is-filled $r2]} {
		    return [expr {$t in {l r1}}]
		} elseif {[$self is-filled $r1] && $cr2} {
		    return [expr {$t in {l r2}}]
		}
	    }
	}
	return 0
    }
    # find the z-shadow cast by this tile on the next layer
    method compute-z-shadow {xyz} {
	foreach {x y z} $xyz break
	set shadow {}
	if {$z > 0} {
	    set x0 [expr {$x-0.5}]
	    set x1 [expr {$x+0.5}]
	    set y0 [expr {$y-0.5}]
	    set y1 [expr {$y+0.5}]
	    foreach slot [$self layer-slots [expr {$z-1}]] {
		foreach {nx ny nz} $slot break
		if {(min($x1,$nx+0.5)-max($x0,$nx-0.5)) > 0 
		    && (min($y1,$ny+0.5)-max($y0,$ny-0.5)) > 0} {
		    lappend shadow $slot
		}
	    }
	}
	$self set $xyz z-shadow $shadow
    }
    method compute-x-closure {xyz} {
	$self set $xyz x-closure [$self compute-relation-closure $xyz x-adjacent]
    }
    method compute-relation-closure {xyz relation} {
	array set closure {}
	set level 1
	set closure($xyz) $level
	set found 1
	while {$found} {
	    set found 0
	    incr level
	    foreach slot [array names closure] {
		if {$closure($slot) != $level-1} continue
		foreach s [$self $relation $slot] {
		    if { ! [info exists closure($s)]} {
			incr found
			set closure($s) $level
		    }
		}
	    }
	}
	# unset closure($xyz)
	return [lsort -real -index 0 [array names closure]]
    }
    # compute the row closure of a slot
    method compute-row-closure {xyz} {
	set rclosure {}
	lappend rowclosure $xyz
	foreach lr {left right} {
	    set closure {}
	    for {set new [$self $lr-adjacent $xyz]} {[llength $new] > 0} {set new $nnew} {
		set nnew {}
		foreach slot $new {
		    if {[lsearch $closure $slot] < 0} {
			lappend closure $slot
			lappend nnew {*}[$self $lr-adjacent $slot]
		    }
		}
	    }
	    lappend rowclosure {*}$closure
	}
	$self set $xyz row-closure [lsort -real -index 0 [lsort -real -index 1 $rowclosure]]
	$self set $xyz left-closure [lmap s [$self row-closure $xyz] {expr {[lindex $s 0] <= [lindex $xyz 0] ? $s : [continue]}}]
	$self set $xyz right-closure [lmap s [$self row-closure $xyz] {expr {[lindex $s 0] >= [lindex $xyz 0] ? $s : [continue]}}]
    }

    # return the z-shadow of a slot
    method z-shadow {xyz} { return [$self get $xyz z-shadow] }
    # return the x-adjacent of a slot
    method x-adjacent {xyz} { return [$self get $xyz x-adjacent] }
    # return the x-adjacent closure of a slot
    method x-closure {xyz} { return [$self get $xyz x-closure] }
    # return the left x-adjacent
    method left-adjacent {xyz} { return [$self get $xyz left-adjacent] }
    # return the right x-adjacent
    method right-adjacent {xyz} { return [$self get $xyz right-adjacent] }
    # return the block of the slot
    method block {xyz} { return [$self get $xyz block] }
    # return the row of a slot
    method row {xyz} { return [$self get $xyz row] }
    # return the row closure of a slot
    method row-closure {xyz} { return [$self get $xyz row-closure] }
    method left-closure {xyz} { return [$self get $xyz left-closure] }
    method right-closure {xyz} { return [$self get $xyz right-closure] }
    # number of empty slots, all filled, or all empty
    method number-empty {slots} { return [tcl::mathop::+ {*}[lmap s $slots {$self is-empty $s}]] }
    method all-filled {slots} {	return [expr {[$self number-empty $slots] == 0}] }
    method all-empty {slots} { return [expr  {[$self number-empty $slots] == [llength $slots]}] }
    method any-filled {slots} { return [expr {[$self number-empty $slots] < [llength $slots]}] }
    # well known slot sets all filled or all empty
    method any-filled-x-adjacent {xyz} { return [$self any-filled [$self x-adjacent $xyz]] } 
    method all-filled-left-adjacent {xyz} { return [$self all-filled [$self left-adjacent $xyz]] }
    method all-filled-right-adjacent {xyz}  { return [$self all-filled [$self right-adjacent $xyz]] }
    method all-empty-left-adjacent {xyz} { return [$self all-empty [$self left-adjacent $xyz]] }
    method all-empty-right-adjacent {xyz}  { return [$self all-empty [$self right-adjacent $xyz]] }
    # can a slot be played
    method can-play {slot} {
	# cannot play an empty slot
	if {[$self is-empty $slot]} { return 0 }
	# cannot play if covered in z
	if {[$self is-covered-in-z $slot]} { return 0 }
	# cannot play if covered in x
	if {[$self is-covered-in-x $slot]} { return 0 }
	return 1
    }
    method is-covered-in-z {slot} {
	foreach s [$self layer-slots [expr {[slot-z $slot]+1}]] {
	    if {[$self is-filled $s] && $slot in [$self z-shadow $s]} {
		return 1
	    }
	}
	return 0
    }
    method is-covered-in-x {slot} {
	if {[$self is-endcap $slot]} { return 0 }
	if {[$self all-empty-left-adjacent $slot]} { return 0 }
	if {[$self all-empty-right-adjacent $slot]} { return 0 }
	return 1
    }
    # can a slot be unplayed
    method can-unplay {slot {donotblock {}}} {
	# cannot unplay a filled slot
	if { ! [$self is-empty $slot]} { return 0 }
	# cannot unplay a slot over an empty slot in z
	if {[$self covers-empty-in-z $slot]} { return 0 }
	# cannot unplay a slot over an empty slot in x
	if {[$self covers-empty-in-x $slot]} { return 0 }
	# if donotblock is present, do not play next to or over it
	if {$donotblock ne {}} {
	    # this is the last bug in the game generator, if you
	    # choose the two slots to unplay independently, then
	    # the second can block the first, to be a legal unplay
	    # you have to be able to play the slots in either order
	    if {[$self blocks-in $slot $donotblock]} { return 0 }
	}
	# that was the last bug, but there is another. it is possible to
	# unplay legal moves to a deadlock. so I need to look ahead to
	# choose the best unplayable, or somehow finesse the problem
	return 1;
    }
    #
    method covers-empty-in-z {slot} {
	return [tcl::mathop::+ {*}[lmap s [$self z-shadow $slot] {$self is-empty $s}]]
    }
    #
    method covers-empty-in-x {slot} {
	# Each x-adjacent-closure shall start in one compartment
	# there are ways that multiple seeds could start in 
	# different rows in the compartment and grow together
	# but the growth cannot cross a boundary between different 
	# numbers of rows except when the crossing into row(s) is(are)
	# completely covered by the crossing out of row(s)
	set x [$self x-closure $slot]
	set n [llength $x]
	set ne [tcl::mathop::+ {*}[lmap s $x {$self is-empty $s}]]
	# entirely empty, any slot will do
	if {$ne == $n} { return 0 }
	# one slot left, it will do
	if {$ne == 1} { return 0 }
	# if it is an endcap slot
	if {[$self is-endcap $slot]} {
	    # all neighbors filled, it will do else wait until they're filled
	    if {[$self all-filled [$self x-adjacent $slot]]} { return 0 } else { return 1 }
	}
	# this block is empty, but the closure is not empty
	if {[$self all-empty [$self block $slot]]} {
	    # if all our neighbors to one side are filled, then okay, else not
	    if {[$self all-filled-left-adjacent $slot] || [$self all-filled-right-adjacent $slot]} {
		return 0 } else { return 1 }
	}
	# this block is not empty
	# this row, and its extensions into adjoining blocks are all empty
	# this is the key, isn't it?
	if {[$self all-empty [$self row-closure $slot]]} {
	    # if we are in a block that contains filled slots
	    # but a row that is empty, then any slot in the row
	    # is acceptable, but only if the rows connected to this
	    # row in the closure are empty, too.
	    return 0
	} else {
	    # if we are in a row closure that contains filled slots
	    # then if we are adjacent to a filled slot, okay,
	    # else not okay
	    if {[$self all-filled-left-adjacent $slot]} {
		return 0
	    } elseif {[$self all-filled-right-adjacent $slot]} {
		return 0
	    } 
	    # if there is a junction where two slots are x-adjacent to one slot,
	    # and one of the two slots filled,
	    # and the outward row closure empty for the other two slots
	    # then the other two slots may be unplayed onto
	    if {[$self is-triple-point $slot] &&
		[$self triple-point-eval $slot]
	    } {
		return 0
	    }
	    return 1
	}
	error "failed to classify case"
    }
    # does slot $sl1 block in slot $sl2
    method blocks-in {sl1 sl2} {
	# sl1 is on top of sl2 and blocks it in
	if {$sl2 in [$self z-shadow $sl1]} {
	    return 1
	}
	# sl1 is not next to sl2
	if {$sl2 ni [$self x-adjacent $sl1]} {
	    return 0
	}
	# sl2 is free on the other side
	if {[$self is-endcap $sl2]} {
	    return 0
	}
	# sl1 is to the left of sl2
	if {$sl1 in [$self left-adjacent $sl2]} {
	    # and there is nothing to the right
	    return [expr { ! [$self all-empty-right-adjacent $sl2]}]
	}
	# sl1 is to the right of sl2
	# and there is nothing to the left
	return [expr { ! [$self all-empty-left-adjacent $sl2]}]
    }
}

#
# I currently render the tiles svg file into a png using inkscape. The svg renders into
# an image with two rows of 44 tiles each.  The top row contains the unselected images 
# and the bottom row the selected images.  The list initializing the -tiles option below
# gives the names of the tiles.
#
# This set of tile images includes a spare white dragon, one drawn with Ubuntu branding 
# and the other rendering as a blank white tile.  A complete game set includes four of 
# each tile except for the seasons and flowers bonus tiles, which are each a set of four
# as they come.
#
# The mahjong::tiles type runs inkscape to create an appropriately sized image and then
# splits the tile images out of the resulting png.  It would be better to generate the
# images without the use of inkscape.  A full set of game tile names are defined and the
# appropriate tile images are associated with each tile name.
#
snit::type mahjong::tiles {
    option -svg -default false -readonly true
    option -png -default false -readonly true
    option -data -default {} -readonly true
    option -file -default {} -readonly true
    option -width -default 64 -configuremethod Configure
    option -height -default 88 -configuremethod Configure
    option -tiles -readonly true -default {
	one-coin two-coins three-coins four-coins five-coins six-coins seven-coins eight-coins nine-coins
	north-wind west-wind south-wind east-wind red-dragon green-dragon
	one-character two-character three-character four-character five-character six-character seven-character eight-character nine-character 
	one-bamboo two-bamboo three-bamboo four-bamboo five-bamboo six-bamboo seven-bamboo eight-bamboo nine-bamboo 
	season-1 season-2 season-3 season-4 white-dragon flower-1 flower-2 flower-3 flower-4 plain-tile selected-tile
    }
    option -pieces -readonly true
    option -normal -readonly true
    option -select -readonly true

    variable map [dict create]

    component img
    
    delegate method rescale to img
    
    constructor {args} {
	$self configure {*}$args

	set n [llength $options(-tiles)]
	set twid $options(-width)
	set thgt [expr {$twid*11/8}]
	set options(-height) $thgt
	if {$options(-png)} {
	    if {$options(-data) ne {}} {
		set img [mahjong::png $self.png -data $options(-data) -tiles $options(-tiles)]
	    } elseif {$options(-file) ne {}} {
		set img [mahjong::png $self.png -file $options(-file) -tiles $options(-tiles)]
	    } else {
		error "must specify -data or -file for tile images"
	    }
	    set options(-width) [$img cget -tile-width]
	    set options(-height) [$img cget -tile-height]
	} elseif {$options(-svg)} {
	    if {$options(-data) ne {}} {
		set img [mahjong::svg $self.svg -data $options(-data)]
	    } elseif {$options(-file) ne {}} {
		set img [mahjong::svg $self.svg -file $options(-file)]
	    } else {
		error "must specify -data or -file for tile images"
	    }
	} else {
	    error "must specify -svg or -png for tile images"
	}
	set options(-normal) {}
	set options(-select) {}
	for {set i 0} {$i < $n-2} {incr i} {
	    set name [lindex $options(-tiles) $i]
	    if {$name ne {}} {
		switch -glob $name {
		    season-* - flower-* { set card 1 }
		    default { set card 4 }
		}
		for {set j 1} {$j <= $card} {incr j} {
		    set tname "$name#$j"
		    dict set map $tname name $name
		    if {$card == 4} {
			dict set map $tname match $name
		    } else {
			dict set map $tname match [string range $name 0 end-2]
		    }
		}
	    }
	}
    }
    # tiles returns a complete tile set, list of name#instance
    method get-tiles {} { return [dict keys $map] }
    # normal returns the normal image for a tile
    method normal {name} { return [list plain-$name face-$name] } 
    # select returns the selected image for a tile
    method select {name} { return [list selected-$name face-$name] } 
    # match tests if the first tile matches the second tile
    method match {name1 name2} { return [expr {[dict get $map $name1 match] eq [dict get $map $name2 match]}] }
    # draw a tile
    method draw {window tile x y s} {
	$img draw $window selected-tile $x $y $s $s [list $tile selected]
	$img draw $window plain-tile $x $y $s $s [list $tile plain]
	$img draw $window [dict get $map $tile name] $x $y $s $s [list $tile face]
    }
    method Configure {opt val} {
	switch -- $opt {
	    -width { 
		set options(-width) $val
		set options(-height) [expr {11*$val/8}]
	    }
	    -height {
		set options(-height) $val
		set options(-width) [expr {8*$val/11}]
	    }
	}
    }
}

proc report-option-classes {win {indent {}}} {
    puts "$win [winfo class $win]"
    foreach o [$win configure] {
	if {[llength $o] < 5} continue
	foreach {opt name class val val} $o break
	puts "$win.$name $class"
	if {$name eq {style}} { puts "$win.style == [$win cget -style]" }
    }
    foreach c [winfo children $win] {
	report-option-classes $c
    }
}

snit::widgetadaptor mahjong::canvas {
    option -layout -readonly true
    option -tiles -readonly true
    option -prefs -readonly true
    option -shuffled-tiles -readonly true
    option -shuffled-slots -readonly true
    option -offsets -default {0 0} -readonly true

    option -title mahjong
    option -game -default 0
    option -start-timer 0
    option -stop-timer 0
    option -remaining-moves 0
    option -remaining-tiles 0
    
    option -trace false
    option -infinite false
    option -watch true
    option -raw-deal false
    option -zoomed -default true -configuremethod wm-attribute
    option -fullscreen -default false -configuremethod wm-attribute

    option -svg -default {}
    option -png -default {}

    component layout
    component tiles

    delegate option -width to tiles
    delegate option -height to tiles

    delegate method get-tiles to tiles
    delegate method match to tiles

    delegate method set-slot to layout
    delegate method set-empty to layout
    delegate method layer-slots to layout
    delegate method is-endcap to layout
    delegate method is-naked-endcap to layout
    delegate method z-shadow to layout
    delegate method x-adjacent to layout
    delegate method can-unplay to layout
    delegate method can-play to layout
    
    delegate option * to hull
    delegate method * to hull
    
    variable data [dict create selected {} paused false scores {} current-score {}]
    
    constructor {args} {
	if {$::usetkpath} {
	    installhull using ::tkp::canvas
	} else {
	    installhull using ::canvas
	}
	bind $win <Destroy> [list {*}[mymethod destroy-window] %W]
	bind $win <Configure> [list {*}[mymethod adjust-window] %W]
	bind $win <Button-3> [list {*}[mymethod menu-popup] %W %x %y]
	$self configure {*}$args
	set layout $options(-layout)
	set tiles $options(-tiles)
	set prefs $options(-prefs)
	if {[catch {$self load-prefs} error]} { $self trace-puts "load-prefs: $error\n$::errorInfo" }
	if {[catch {$self load-scores} error]} { $self trace-puts "load-scores: $error\n$::errorInfo" }
	$self configure {*}$args; # command line options override preferences
	$self menu-build
    }
    
    method {wm-attribute -zoomed} {value} {
	set options(-zoomed) $value
	wm attribute . -zoomed $value
    }
    method {wm-attribute -fullscreen} {value} {
	set options(-fullscreen) $value
	wm attribute . -fullscreen $value
    }
    method set-name-slot {name slot} { dict set data name-to-slot $name $slot }
    method get-name-slot {name} { return [dict get $data name-to-slot $name] }
    method set-slot-name {slot name} { $options(-layout) set-slot $slot $name }
    method get-slot-name {slot} { return [$options(-layout) get-slot $slot] }
    method is-empty-slot {slot} { return [$options(-layout) is-empty $slot] }
    method get-all-slots {} { return [$options(-layout) get-slots] }
    
    method get-remaining-tiles {} {
	return [lmap name [$self get-tiles] {expr {[$self get-name-slot $name] ne {} ? $name : [continue]}}]
    }

    method tile-sizes {} {
	set twid [$self cget -width];   # tile width
	set thgt [$self cget -height];  # tile height
	set xstep [expr {$twid/10.0}];  # offset for 3d border
	set ystep [expr {$thgt/11.0}];  # offset for 3d border
	set fwid [expr {$twid-$xstep}];	# tile face width
	set fhgt [expr {$thgt-$ystep}];	# tile face height
	return [list $twid $thgt $xstep $ystep $fwid $fhgt]
    }

    method xy-for-slot {slot} {
	foreach {twid thgt xstep ystep fwid fhgt} [$self tile-sizes] break
	foreach {x y z} $slot break;	# slot
	set x [expr {$x*$fwid + $z*$xstep}]
	set y [expr {$y*$fhgt - $z*$ystep}]
	return [list $x $y]
    }

    # context menu, button 3 or 2 on the background
    # with single character accelerators on the root window
    method menu-build {} {
	# popup menu
	menu .m -tearoff no
	set accels {}
	foreach record {
	    {command n {New Game} new-game}
	    {command o {Restart} restart-game}
	    {separator}
	    {command p {Pause} pause-game}
	    {command c {Continue} continue-game}
	    {separator}
	    {command h {Hint} hint}
	    {command u {Undo} undo}
	    {command r {Redo} redo}
	    {separator}
	    {hint m {Menu} menu-menu}
	    {command s {Scores} scores}
	    {command f {Preferences} preferences}
	    {command ? {Help} help}
	    {separator}
	    {command b {By Name} by-name}
	    {menu {} {Draw Frame} draw-frame {0 1 2 3 4 5 6}}
	    {separator}
	    {command q {Quit} quit-game}
	} {
	    foreach {entry accelerator label meth var} $record break
	    if {$record ne {separator}} {
		if {[lsearch -exact $accels $accelerator] >= 0} { error "duplicate accelerator for $record" }
		lappend accels $accelerator
	    }
	    switch $entry {
		separator {
		    .m add separator
		}
		command {
		    .m add command -accelerator $accelerator -label $label -command [mymethod $meth]
		    if {$accelerator eq {?}} { set accelerator question }
		    bind . <KeyPress-$accelerator> [list {*}[mymethod menu-protect] $label $meth]
		}
		checkbutton {
		    .m add checkbutton -accelerator $accelerator -label $label -variable [myvar $var]
		    bind . <KeyPress-$accelerator> [list {*}[mymethod menu-protect] $label $meth]
		}
		hint {
		    .m add command -accelerator $accelerator -label $label
		    bind . <KeyPress-$accelerator> [mymethod $meth]
		}
		menu {
		    menu .m.$meth -tearoff no
		    .m add cascade -label $label -menu .m.$meth
		    foreach i $var {
			.m.$meth add radiobutton -label "Level $i" -value $i -command [list {*}[mymethod $meth] $i]
		    }
		}
		default {
		    error "unexpected menu entry command $entry"
		}
	    }
	}
    }
    # popup the menu when we are over the background
    method menu-popup {w x y} {
	if {[$win find withtag current] eq {}}  { tk_popup .m $x $y }
    }
    # enable and disable lists of menu entries
    method menu-enable-disable {enable disable} {
	foreach label $enable { .m entryconfigure $label -state normal }
	foreach label $disable { .m entryconfigure $label -state disabled }
    }
    # protect an accelerator from calling the entry function when disabled
    method menu-protect {label meth} {
	# puts "$self menu-protect $label $meth"
	if {[.m entrycget $label -state] eq {normal}} {
	    $self $meth
	}
    }
    
    ##
    ## menu functions
    ##
    method first-game {} {
	if {$options(-game) ne {0}} {
	    $self trace-puts "new-game $options(-game)"
	    $self new-game [scan-game $options(-game)]
	} else {
	    set game [clock seconds]
	    $self trace-puts "new-game [format-game $game]"
	    $self new-game $game
	}
	if {$options(-infinite)} {
	    while {1} {
		set game [clock seconds]
		$self trace-puts "new-game [format-game $game]"
		$self new-game $game
	    }
	}
    }
    
    method new-game {{game {}}} {
	$self setup $game
	while {[catch {$self restart} error]} {
	    if {$error eq {cannot unplay}} {
		# $self trace-puts "$error\n$::errorInfo"
		set options(-shuffled-slots) [shuffle $options(-shuffled-slots)]
		$self trace-puts "retrying new game"
	    } else {
		$self trace-puts "$error\n$::errorInfo"
		set options(-shuffled-slots) [shuffle $options(-shuffled-slots)]
		$self trace-puts "retrying new game"
	    }
	}
    }
    method restart-game {} { $self restart }
    method pause-game {} {
	$self clear-selected
	dict set data paused true
	$self pause-timer
	foreach tile [$self get-remaining-tiles] { $self show [$self get-name-slot $tile] $tile blank }
	$self menu-enable-disable {{Continue}} {{New Game} {Restart} {Pause} {Hint} {Undo} {Redo} {Scores} {Preferences} {Help}}
    }
    method continue-game {} {
	$self menu-enable-disable {{New Game} {Restart} {Pause} {Hint} {Undo} {Redo} {Scores} {Preferences}} {{Continue}}
	foreach tile [$self get-remaining-tiles] { $self show [$self get-name-slot $tile] $tile plain }
	$self continue-timer
	dict set data paused false
	
    }
    method hint {} {
	set slots [concat {*}[$self find-moves]]
	if {$slots ne {}} {
	    dict incr data hint
	    set slot [lindex $slots [expr {[dict get $data hint]%[llength $slots]}]]
	    $self set-selected $slot [$self get-slot-name $slot]
	}
    }
    method undo {} { $self history-undo }
    method redo {} { $self history-redo }
    method menu-menu {} { $self menu-popup . 100 100 }
    method scores {} { $self scores-window }
    method scores-window {} {
	toplevel .scores
	wm title .scores {Scores}
	pack [ttk::button .scores.close -text Close -command [list destroy .scores]] -side top

    }
    method preferences {} {
	toplevel .preferences
	wm title .preferences {Preferences}
	foreach opt {watch raw-deal trace} {
	    pack [ttk::checkbutton .preferences.$opt -text $opt -variable [myvar options(-$opt)]] -side top -expand true -fill x
	}
	pack [ttk::button .preferences.close -text Close -command [list destroy .preferences]] -side top
	#report-option-classes .preferences
    }
    method help {} { 
	toplevel .help
	wm title .help {Help}
	grid [text .help.text -yscrollcommand [list .help.scrollbar set]] -column 0 -row 0 -sticky nsew
	foreach t {
	    {Mahjong solitaire is played by selecting matching pairs of tiles and removing them from the layout.}
	    {}
	    {The layout is constructed so that there is always at least one solution.}
	    {}
	    {The controls are available as hot key commands or from a right mouse menu on the game's background.}
	} {
	    .help.text insert end $t\n
	}
	grid [ttk::scrollbar .help.scrollbar -orient vertical -command [list .help.text yview]] -column 1 -row 0 -sticky ns
	grid [ttk::button .help.close -text Close -command [list destroy .help]] -column 0 -row 1 -columnspan 2
    }
    method by-name {} {
	toplevel .byname
	wm title .byname {By Name}
	grid [ttk::label .byname.l -text {Choose game by name}] -row 1 -column 0 -columnspan 2 -sticky ew 
	grid [ttk::entry .byname.e] -row 2 -column 0 -columnspan 2 -sticky ew
	.byname.e insert end [format-game $options(-game)]
	grid [ttk::button .byname.okay -text Okay -command [mymethod by-name-okay]] -row 3 -column 0 -sticky ew
	grid [ttk::button .byname.cancel -text Cancel -command [list destroy .byname]] -row 3 -column 1 -sticky ew
	#report-option-classes .byname
    }
    method by-name-okay {how} {
	set options(-game) [scan-game [.byname.e get]]
	destroy .byname
	$self new-game $options(-game)
    }
    method draw-frame {level} {
	$win delete frame
	foreach {twid thgt xstep ystep fwid fhgt} [$self tile-sizes] break
	foreach slot [$self layer-slots $level] {
	    foreach {x y} [$self xy-for-slot $slot] break
	    set x [expr {$x+$xstep}]
	    $win create rectangle $x $y [expr {$x+$fwid}] [expr {$y+$fhgt}] -fill {} -outline white -tags frame
	    $win create text [expr {$x+10}] [expr {$y+$ystep+10}] -anchor nw -text $slot -fill white -tags frame
	}
	$win lower frame
	$win move frame {*}$options(-offsets)
    }
	
    method quit-game {} { destroy . }
    
    ##
    ## window display helpers
    ##
    method apply-offsets {offsets} { 
	# puts "$self apply-offsets $offsets"
	$win move all {*}$offsets 
    }
    method invert-offsets {offsets} { return [lmap a $offsets {expr {-$a}}] }
    method rescale {n d} { 
	set s [expr {double($n)/$d}]
	# puts "$self rescale $s"
	$win scale all 0 0 $s $s
	if {[dict exists $data coords]} {
	    set coords [dict get $data coords]
	    foreach name [dict keys $coords] {
		dict set coords $name [lmap x [dict get $coords $name] {expr {$s*$x}}]
	    }
	    dict set data coords $coords
	}
	foreach id [$win find withtag scale-width] {
	    $win itemconfigure $id -width [expr {$s*[$win itemcget $id -width]}]
	}
	$tiles rescale $win $n $d
    }
    # compute the xoff yoff that centers the current 
    method adjust-window {window} {
	if {$window ne $win} return
	if {[set w [winfo width $win]] == 1} return
	if {[set h [winfo height $win]] == 1} return
	$self trace-puts "adjust-window"
	catch {after cancel [dict get $data adjust-window]}
	dict set data adjust-window [after 100 {*}[mymethod do-adjust-window] $window]
    }

    method do-adjust-window {window} {
	if {$window ne $win} return
	if {[set w [winfo width $win]] == 1} return
	if {[set h [winfo height $win]] == 1} return
	$self trace-puts "do-adjust-window"
	# undo current offsets
	$self apply-offsets [$self invert-offsets $options(-offsets)]
	# compute new scale and apply
	set width [expr {int(64*min(($w/64.0)/11.0, ($h/88.0)/7.0))}]
	$self rescale $width [$self cget -width]
	$self configure -width $width
	# compute and apply new offsets
	# these should be face height and width plus one 3d border
	foreach {twid thgt xstep ystep fwid fhgt} [$self tile-sizes] break
	set lwidth [expr {11*$fwid+$xstep}]
	set lheight [expr {7*$fhgt+$ystep}]
	set xoff [expr {($w-($lwidth))/2}]
	set yoff [expr {($h-($lheight))/2}]
	set options(-offsets) [list $xoff $yoff]
	$self apply-offsets $options(-offsets)
	$self check-all-tile-coords
    }
    
    method check-tile-coords {slot name} {
	set bbox [$win bbox $name]
	if {$bbox eq {}} return
	foreach {x1 y1 x2 y2} $bbox break
	foreach {x y z} $slot break
	foreach {cx cy} [dict get $data coords $name] break
	foreach {xo yo} $options(-offsets) break
	set dx [expr {($x1-$xo)}]
	set dy [expr {($y1-$yo)}]
	if {pow($dx-$cx,2)+pow($dy-$cy,2) > ([$self cget -width]+[$self cget -height])/10} {
	    $self trace-puts "$slot $name $dx $dy $cx $cy [$self xy-for-slot $slot] [lsearch $options(-shuffled-tiles) $name]"
	}
    }
    
    method check-all-tile-coords {} {
	$self trace-puts "check-all-tile-coords"
	set empties 0
	set slots {}
	set names {}
	foreach slot [$self get-all-slots] {
	    if {[$self is-empty-slot $slot]} continue
	    $self check-tile-coords $slot [$self get-slot-name $slot]
	}
    }
		
    method destroy-window {window} {
	if {$window ne $win} return
	catch {$self score-game-save}
	catch {$self save-prefs}
    }
    
    method save-prefs {} {
	$options(-prefs) save-prefs [list \
					 zoomed $options(-zoomed) \
					 fullscreen $options(-fullscreen) \
					 geometry [wm geometry .] \
					 watch $options(-watch) \
					 raw-deal $options(-raw-deal) \
					 trace $options(-trace) \
					]
    }
    method save-scores {} {
	$options(-prefs) save-scores [dict get $data scores]
    }
    method load-prefs {} {
	#puts "enter load-prefs in mahjong::canvas"
	array set prefs [$options(-prefs) load-prefs]
	#puts "load-prefs prefs are {[array get prefs]}"
	if {[info exists prefs(fullscreen)] && $prefs(fullscreen)} {
	    wm attributes . -fullscreen 1
	    sdltk fullscreen
	} elseif {[info exists prefs(zoomed)] && $prefs(zoomed)} {
	    wm attributes . -zoomed 1
	    sdltk maximize
	} elseif {[info exists prefs(geometry)]} {
	    wm geometry . $prefs(geometry)
	}
	foreach v {watch trace raw-deal} {
	    if {[info exists prefs($v)]} {
		set options(-$v) $prefs($v)
	    }
	}
    }
    method load-scores {} {
	dict set data scores [$options(-prefs) load-scores]
    }
    ##
    ## game play helpers
    ##
    method get-items {} { return $options(-items) }
    
    proc shuffle {oldlist} {
	set n [llength $oldlist]
	set list $oldlist
	for {set i 0} {$i < $n} {incr i} {
	    set j [expr {$i+int(rand() * ($n-$i))}]
	    if {$i != $j} {
		set li [lindex $list $i]
		set lj [lindex $list $j]
		set list [lreplace [lreplace $list $j $j $li] $i $i $lj]
	    }
	}
	return $list
    }
    
    method sort-matching {names} {
 	set sort {}
 	while {[llength $names] > 0} {
 	    set name1 [lindex $names 0]
 	    set names [lrange $names 1 end]
 	    lappend sort $name1
 	    for {set n2 0} {$n2 < [llength $names]} {incr n2} {
 		set name2 [lindex $names $n2]
 		if {[$self match $name1 $name2]} {
 		    lappend sort $name2
 		    set names [lreplace $names $n2 $n2]
 		    break
 		}
 	    }
 	}
 	# $self trace-puts [lmap i $sort {$self item-to-name $i}]
 	return $sort
    }
    
    method sort-fertility {slots} {
	set plain {}
	set endcaps {}
	foreach slot $slots {
	    if {[$self is-naked-endcap $slot]} {
		lappend endcaps $slot
	    } else {
		lappend plain $slot
	    }
	}
	return [concat $plain $endcaps]
    }

    method raise-in-render-order {} {
	foreach slot [$self get-all-slots] {
	    $win raise [$self get-slot-name $slot]
	}
    }
    
    ##
    ## window title bar status
    ##
    method start-status {} {
	if { ! [dict exists $data status-started]} {
	    dict set data status-started [after 100 [list {*}[mymethod update-status]]]
	}
    }
    
    method update-status {} {
	set gname [format-game $options(-game)]
	set elapsed [$self elapsed-time]
	set elapsed [format {%d:%02d} [expr {$elapsed/60}] [expr {$elapsed%60}]]
	wm title . "$options(-title) - $gname - $elapsed - $options(-remaining-moves) moves, $options(-remaining-tiles) tiles"
	dict set data status-started [after 100 [list {*}[mymethod update-status]]]
    }
    
    method reset-timer {} {
	set options(-start-game) [clock seconds]
	set options(-start-timer) 0
	set options(-stop-timer) 0
    }
    method start-timer {} {
	if {$options(-start-timer) == 0} { set options(-start-timer) [clock seconds] }
    }
    method stop-timer {} {
	if {$options(-stop-timer) == 0} { set options(-stop-timer) [clock seconds] }
    }
    method pause-timer {} {
	if {$options(-stop-timer) == 0} { set options(-stop-timer) [clock seconds] }
    }
    method continue-timer {} {
	if {$options(-stop-timer) != 0} {
	    set options(-start-timer) [expr {[clock seconds]-($options(-stop-timer)-$options(-start-timer))}]
	    set options(-stop-timer) 0
	}
    }
    method elapsed-time {} {
	if {$options(-start-timer) == 0} {
	    return 0
	} elseif {$options(-stop-timer) != 0} {
	    return [expr {$options(-stop-timer) - $options(-start-timer)}]
	} else {
	    return [expr {[clock seconds] - $options(-start-timer)}]
	}
    }
    
    method score-game {time elapsed game remaining-moves remaining-tiles} {
	dict set data current-score [list $time $elapsed $game ${remaining-moves} ${remaining-tiles}]
    }
    method score-game-save {} {
	if {[dict get $data current-score] ne {}} {
	    dict lappend data scores [dict get $data current-score]
	    $self save-scores
	}
	dict set data current-score {}
    }
    method update-score {} {
	set options(-remaining-moves) [$self count-moves]
	$self score-game $options(-start-game) [$self elapsed-time] $options(-game) $options(-remaining-moves) $options(-remaining-tiles)
	if {$options(-remaining-moves) == 0} {
	    $self stop-timer
	    if {$options(-remaining-tiles) > 0} {
		# game lost
		set title {There are no more moves.}
		set text [string cat {Each puzzle has at least one solution.} \
			      { You can undo your moves and try and find the solution,}\
			      { restart this game, start a new one, or give up.}]
		set bitmap {}
		set idefault 0
		switch [tk_dialog .gameover $title $text $bitmap $idefault Undo Restart {New game} {Quit}] {
		    1 { $self restart-game }
		    2 { $self new-game }
		    3 { $self quit-game }
		    default { 
			$self continue-timer
			$self undo 
		    }
		}
	    } else {
		# game won, open scores dialog
		set title {You won.}
		set text {Congratulations, you have solved the puzzle.}
		set bitmap {}
		set idefault 0
		switch [tk_dialog .gameover $title $text $bitmap $idefault {New game} Restart {Quit}] {
		    0 { $self new-game }
		    1 { $self restart-game }
		    2 { $self quit-game }
		    -1 { $self new-game }
		}
	    }
	}
    }
    
    method count-moves {} {
	return [llength [$self find-moves]]
    }
    
    proc format-game {game} {
	while {$game != 0} {
	    set c [expr {$game%26}]
	    set game [expr {$game/26}]
	    lappend format [lindex {a b c d e f g h i j k l m n o p q r s t u v w x y z} $c]
	}
	return [join [lreverse $format] {}]
    }
    
    proc scan-game {game} {
	set n 0
	foreach c [split $game {}] {
	    set n [expr {$n*26+[lsearch {a b c d e f g h i j k l m n o p q r s t u v w x y z} $c]}]
	}
	return $n
    }
    
    ##
    ## history maintenance
    ##
    method history-empty {} {
	dict set data history [dict create {*}{
	    count 0
	    future 0
	    items {}
	}]
	dict with data history {
	    $self menu-enable-disable {} {Undo Redo}
	}
    }
    method history-save-reversed {} {
	dict with data history {
	    return [dict create count 0 future $future items [lreverse $items]]
	}
    }
    method history-restore {old} {
	$self clear-selected
	dict set data history $old
	dict with data history {
	    if {$count < $future} {
		$self menu-enable-disable {Undo Redo} {}
	    } else {
		$self menu-enable-disable {Undo} {Redo}
	    }
	}
    }
    method history-get-count {} { return [dict get $data history count] }
    method history-get-future {} { return [dict get $data history future] }
    method history-get-items {} { return [dict get $data history items] }
    method history-add {nm1 sl1 nm2 sl2} {
	$self clear-selected
	dict with data history {
	    if {[llength $items] > $count} {
		set items [lrange $items 0 $count-1]
	    }
	    lappend items [list $nm1 $sl1 $nm2 $sl2]
	    incr count 1
	    set future $count
	    $self menu-enable-disable {Undo} {Redo}
	}
    }
    method history-undo {} {
	# step back
	$self clear-selected
	dict with data history {
	    incr count -1
	    $self move-place {*}[lindex $items $count]
	    if {$count > 0} {
		$self menu-enable-disable {Undo Redo} {}
	    } else {
		$self menu-enable-disable {Redo} {Undo}
	    }
	}
	$self update-score
    }
    method history-redo {} {
	# step forward
	$self clear-selected
	dict with data history {
	    $self move-unplace {*}[lindex $items $count]
	    incr count 1
	    if {$count < $future} {
		$self menu-enable-disable {Undo Redo} {}
	    } else {
		$self menu-enable-disable {Undo} {Redo}
	    }
	}
	$self update-score
    }
    
    ##
    ## setup the next game
    ##
    method setup {{game {}}} {
	# set up for a new game which might be restarted
	# so, game number seeds random number generator, 
	# results in shuffle of -slots and -tiles
	# the optional $game may be supplying a game by name
	# or simply the time
	if {$game eq {}} { set game [clock seconds] }
	set options(-game) $game
	expr {srand($options(-game))}
	set options(-shuffled-slots) [shuffle [$self get-all-slots]]
	set options(-shuffled-tiles) [$self sort-matching [shuffle [$self get-tiles]]]
	$self start-status
    }
    
    ##
    ## start or restart the currently setup game
    ##
    method restart {} {
	# save the result of the last game
	$self score-game-save
	# reset timer
	$self reset-timer
	# clear selection
	$self clear-selected
	# reset slot to name map
	foreach slot [$self get-all-slots] { 
	    set name [$self get-slot-name $slot]
	    if {[$self tile-is-placed $slot $name]} {
		$self tile-unplace $slot $name
		if {$options(-watch)} update
	    }
	    $self set-slot-name $slot {}
	}
	# reset name to slot map
	foreach name [$self get-tiles] { $self set-name-slot $name {} }

	# one update if we are not watch to clear the board
	if { ! $options(-watch)} update

	
	# pick matching pairs from available
	set names $options(-shuffled-tiles)
	set slots $options(-shuffled-slots)
	set moves {}
	set options(-remaining-tiles) 0
	
	# make an initial update
	if {$options(-watch)} update
	
	while {[llength $names]} {
	    if {$options(-remaining-tiles) != 144-[llength $names]} {
		puts "-remaining-tiles $options(-remaining-tiles) != 144-llength names 144-[llength $names]"
	    }
	    if {$options(-remaining-tiles) != [llength [$self get-remaining-tiles]]} {
		puts "-remaining-tiles $options(-remaining-tiles) !=  llength get-remaining-tiles [llength [$self get-remaining-tiles]]"
	    }

	    ## choose the pair of matched tiles to play
	    # take first and second tiles in name list
	    foreach {name1 name2} $names break
	    set names [lrange $names 2 end]

	    # take first open slot in slot list
	    set slot1 [$self find-can-unplay $slots]
	    if {$slot1 eq {}} {
		$self trace-puts "slot1 eq {}"
		break
	    }
	    set s1 [lsearch $slots $slot1]
	    set slots [lreplace $slots $s1 $s1]

	    # put the first tile in its slot
	    $self tile-place $slot1 $name1
	    lappend moves $name1 $slot1

	    if {$options(-watch)} update

	    # take next open slot in slot list
	    # but avoid slots that block $slot1
	    set slot2 [$self find-can-unplay $slots $slot1]

	    while {$slot2 eq {}} {
		# there is no unplayable slot2 that doesn't block slot1
		# undo the unplay farthest from slot1, return the unplayed
		# slots and names to the todo lists, and retry slot2 search
		set bestm {}
		set bestd -1
		foreach m [$self find-moves] {
		    # okay, so the pairs of matching tiles found by search
		    # may not have been unplayed as a pair, which will
		    # make it hard to remove them from the $moves list
		    # so reject pairs that aren't moves in $moves
		    if { ! [$self is-an-unplayed-move {*}$m $moves]} {
			$self trace-puts "! is-an-unplayed-move $m"
			continue
		    }
		    if {[set d [move-distance $slot1 {*}$m]] > $bestd} {
			set bestm $m
			set bestd $d
		    }
		    $self trace-puts "move-distance $m is $d"
		}
		$self trace-puts "bestm is $bestm at distance $bestd"
		# since we are only attempting to undo previously completed moves
		# we won't try to undo slot1 because it's only half a move
		# but we might still be digging a hole and filling it back in
		# if we are too close
		if {$bestm ne {} && $bestd > 7.0} {
		    # undo $bestm
		    $self trace-puts "undoing {$bestm} at $bestd"
		    foreach {moves slots names} [$self undo-unplayed-move {*}$bestm $moves $slots $names] break
		    # redo the search for slot2
		    set slot2 [$self find-can-unplay $slots $slot1]
		    continue
		}
		$self trace-puts "slot2 eq {} backing out $slot1"
		# undo move
		# $self trace-puts "undo move"
		set moves [lrange $moves 0 end-2]
		# $self trace-puts "tile-unplace $slot1 $name1"
		$self tile-unplace $slot1 $name1
		# undo damage
		if {$s1 < [llength $slots]} {
		    set slots [lreplace $slots $s1 $s1 $slot1]
		} else {
		    lappend slots $slot1
		}
		set names [list $name1 $name2 {*}$names] 
		# $self trace-puts "breaking loop"
		# this used to break out of the search loop
		# now it only breaks the slot2 re-search loop
		break
	    }

	    # break the search loop if slot2 failed
	    if {$slot2 eq {}} break
	    
	    set s2 [lsearch $slots $slot2]
	    set slots [lreplace $slots $s2 $s2]
	    
	    # put the second tile in its slot
	    $self tile-place $slot2 $name2
	    
	    # make backwards history
	    lappend moves $name2 $slot2
	    
	    if {$options(-watch)} update
	    
	    # test for forward playability
	    if { ! [$self can-play $slot1]} {
		$self trace-puts "proposed move slot1 $slot1 cannot play"
		break
	    } elseif { ! [$self can-play $slot2]} {
		$self trace-puts "proposed move slot2 $slot2 cannot play"
		break
	    } elseif { ! [$self match $name1 $name2]} {
		$self trace-puts "proposed move mismatches $nm1 and $nm2"
		break
	    }
	}

	# make and save the history of the play
	# this allows the construction of the deal to be played in reverse
	# at the start of each game by redoing moves
	$self history-empty
	foreach {name1 slot1 name2 slot2} $moves {
	    $self history-add $name1 $slot1 $name2 $slot2
	}
	$self history-restore [$self history-save-reversed]
	
	# raise slots in render order
	$self raise-in-render-order
	
	# adjust window
	$self adjust-window $win
	
	# compute
	if {$options(-remaining-tiles) != [llength [$self get-remaining-tiles]]} {
	    puts "-remaining-tiles $options(-remaining-tiles) !=  llength get-remaining-tiles [llength [$self get-remaining-tiles]]"
	}
	set options(-remaining-moves) [$self count-moves]
    }
    
    ##
    ## unplay to avoid deadlock
    ##
    method is-an-unplayed-move {slot1 slot2 moves} {
	set i1 [lsearch $moves $slot1]
	set i2 [lsearch $moves $slot2]
	if {$i1 < 0 || $i2 < 0} { error "what?" }
	if {abs($i1-$i2) == 2} {
	    if {$i1 < $i2 && ($i1%4) == 1} { return 1 }
	    if {$i2 < $i1 && ($i2%4) == 1} { return 1 }
	}
	return 0
    }
    proc slot-distance {slot1 slot2} {
	return [tcl::mathop::+ {*}[lmap a $slot1 b $slot2 {expr {pow($a-$b,2)}}]]
    }
    proc move-distance {slot1 slot2 slot3} {
	return [expr {[slot-distance $slot1 $slot2]+[slot-distance $slot1 $slot3]}]
    }
    method undo-unplayed-move {slot1 slot2 moves slots names} {
	# get the slot indexes
	set i1 [lsearch $moves $slot1]
	set i2 [lsearch $moves $slot2]
	# swap the slots so $i1 < $i2
	if {$i2 < $i1} {
	    foreach {slot1 slot2 i1 i2} [list $slot2 $slot1 $i2 $i1] break
	}
	# get the tiles played in the slots
	set name1 [$self get-slot-name $slot1]
	set name2 [$self get-slot-name $slot2]
	# get the indexes where the move is played
	set j1 [lsearch $moves $name1]
	set j2 [lsearch $moves $name2]
	# test our understanding
	if {$i1 != $j1+1 || $j2 != $i1+1 || $i2 != $j2+1 || ($j1%4) != 0} {
	    error "misunderstood the structure of moves"
	}
	# remove the slots and names from play
	$self tile-unplace $slot1 $name1
	$self tile-unplace $slot2 $name2
	#$self set-slot-name $slot1 {}
	#$self set-slot-name $slot2 {}
	#$self set-name-slot $name1 {}
	#$self set-name-slot $name2 {}
	# remove the move from $moves
	set moves [lreplace $moves $j1 $j1+3]
	# return the slots to $slots
	lappend slots $slot1 $slot2
	# return the tiles to $names
	lappend names $name1 $name2
	# return
	return [list $moves $slots $names]
    }

    ##
    ## game play/unplay mechanics
    ##
    method find-slots-in-play {} {
	return [lmap s [$self get-all-slots] {expr {[$self is-empty-slot $s]?[continue]:$s}}]
    }
    method find-moves {} {
	set moves {}
	set slots [$self find-slots-in-play]
	set slots [$self find-all-can-play $slots]
	for {set i 0} {$i < [llength $slots]} {incr i} {
	    set si [lindex $slots $i]
	    set ni [$self get-slot-name $si]
	    for {set j [expr {$i+1}]} {$j < [llength $slots]} {incr j} {
		set sj [lindex $slots $j]
		set nj [$self get-slot-name $sj]
		if {[$self match $ni $nj]} {
		    lappend moves [list $si $sj]
		}
	    }
	}
	return $moves
    }
    
    proc slot-histogram {slots} {
	set stats [dict create -1 [llength $slots] 0 0 1 0 2 0 3 0 4 0 5 0 6 0]
	foreach slot $slots { dict incr stats [lindex $slot 2] }
	return $stats
    }
    method stats-for-slots {slots} {
	set hist [slot-histogram $slots]
	set full [slot-histogram [$self get-all-slots]]
	set quot {}
	foreach n [dict keys $hist] { lappend quot "[dict get $hist $n]/[dict get $full $n]" }
	return $quot
    }
    method trace-puts {str} {
	if {$options(-trace)} {
	    if { ! [dict exists $data fp]} {
		dict set data fp [open "trace.data" w]
	    }
	    puts [dict get $data fp] $str
	    flush [dict get $data fp]
	}
    }
    method find-can-unplay {slots {donotblock {}}} {
	if {0} {
	    set veryfirst {}
	    foreach slot [$self find-all-can-unplay $slots $donotblock] {
		if {[$self is-naked-endcap $slot]} { 
		    if {$veryfirst eq {}} { set veryfirst $slot }
		} else {
		    return $slot
		}
	    }
	    if {$veryfirst ne {}} { return $veryfirst }
	} else {
	    foreach slot $slots {
		if {[$self can-unplay $slot $donotblock]} {
		    return $slot
		}
	    }
	}
	$self trace-puts "cannot unplay donotblock={$donotblock}: all={[$self find-all-can-unplay $slots]} [$self stats-for-slots $slots]"
	$self trace-puts "  slots={$slots}"
	$self trace-puts "  moves={[uplevel {set moves}]}"
	if {0} {
	    foreach slot {{1.0 1.0 1} {2.0 1.0 1} {3.0 1.0 1}} {
		$self trace-puts "  can-unplay $slot [$self can-unplay $slot]"
		$self trace-puts "  covers-empty-in-z $slot [$layout covers-empty-in-z $slot]"
		$self trace-puts "  is-empty $slot [$layout is-empty $slot]"
		$self trace-puts "  covers-empty-in-x $slot [$layout covers-empty-in-x $slot]"
		$self trace-puts "  row-closure $slot [$layout row-closure $slot]"
	    }
	}
	return {}
	error "cannot unplay"
    }
    method find-all-can-unplay {slots {donotblock {}}} {
	return [lmap slot $slots {
	    expr {[$self can-unplay $slot $donotblock] ? $slot : [continue]}
	}]
    }
    method find-can-play {slots} {
	foreach slot $slots {
	    if {[$self can-play $slot]} { return $slot }
	}
	error "cannot play"
    }
    method find-all-can-play {slots} {
	return [lmap slot $slots {
	    expr {[$self can-play $slot] ? $slot : [continue]}
	}]
    }
    ##
    ##
    ##
    method draw {slot name} {
	foreach {x y} [$self xy-for-slot $slot] break
	if {[$win find withtag $name] eq {}} {
	    set scale [expr {[$self cget -width]/64.0}]
	    $tiles draw $win $name 0 0 1
	    $win scale $name 0 0 $scale $scale
	    foreach id [$win find withtag $name] {
		if {[lsearch [$win itemcget $id -tags] scale-width] >= 0} {
		    $win itemconfigure $id -width [expr {$scale*[$win itemcget $id -width]}]
		}
	    }
	    $win move $name $x $y
	    $win move $name {*}$options(-offsets)
	} else {
	    foreach {ox oy} [dict get $data coords $name] break
	    $win move $name [expr {$x-$ox}] [expr {$y-$oy}]
	}
	dict set data coords $name [list $x $y]
	# $self check-tile-coords $slot $name
    }

    method show {slot name tag} {
	foreach id [$win find withtag $name] {
	    set tags [$win itemcget $id -tags]
	    switch $tag {
		plain -
		selected {
		    if {[lsearch $tags $tag] >= 0 || [lsearch $tags face] >= 0} {
			$win itemconfigure $id -state normal
		    } else {
			$win itemconfigure $id -state hidden
		    }
		}
		blank {
		    if {[lsearch $tags plain] >= 0} {
			$win itemconfigure $id -state normal
		    } else {
			$win itemconfigure $id -state hidden
		    }
		}
	    }
	}
    }
    method hide {slot name} {
 	$win itemconfigure $name -state hidden
    }
    ##
    ##
    ##
    method move-place {name1 slot1 name2 slot2} {
	$self tile-place $slot1 $name1
	$self tile-place $slot2 $name2
    }
    method move-unplace {name1 slot1 name2 slot2} {
	$self tile-unplace $slot1 $name1
	$self tile-unplace $slot2 $name2
    }
    method tile-place {slot name} {
	#$self trace-puts "$self tile-place $slot $name $draw"
	$self set-slot-name $slot $name
	$self set-name-slot $name $slot
	$self draw $slot $name
	$self show $slot $name plain
	$win bind $name <Enter> [list {*}[mymethod enter] $slot $name]
	$win bind $name <Leave> [list {*}[mymethod leave] $slot $name]
	$self raise-in-render-order
	incr options(-remaining-tiles) 1
    }
    
    method tile-unplace {slot name} {
 	$self set-name-slot $name {}
	$self set-slot-name $slot {}
	$self hide $slot $name
	$win bind $name <Enter> {}
	$win bind $name <Leave> {}
	incr options(-remaining-tiles) -1
    }
    method tile-is-placed {slot name} {
	return [expr {[$self get-slot-name $slot] eq $name}]
    }
    ##
    ## tile mouse event handlers
    ## mostly concerned with selected tile management
    ## set-selected {slot name}
    ##
    method get-selected {} { return [dict get $data selected] }
    method is-selected {} { return [expr {[$self get-selected] ne {}}] }
    method clear-selected {} {
	if {[$self is-selected]} { $self show {*}[$self get-selected] plain }
	dict set data selected {}
    }
    method set-selected {args} { 
	$self clear-selected
	if {$args ne {}} { $self show {*}$args selected	}
	dict set data selected $args
    }
    
    method enter {slot name} { 
	$win bind $name <Button-1> [list {*}[mymethod button] $slot $name] 
    }
    method leave {slot name} {
	$win bind $name <Button-1> {}
    }
    
    method button {slot1 name1} {
	if {[dict get $data paused]} return
	# if the tile is playable
	if {[$self can-play $slot1]} {
	    # if there's an already selected tile
	    if {[$self is-selected]} {
		# get the selected tile and clear the selection
		foreach {slot2 name2} [$self get-selected] break
		$self clear-selected
		if {$name1 eq $name2} {
		    # if it's the same tile
		    # just return, we've cancelled the selection
		    # and undone the selected image
		} elseif {[$self match $name1 $name2]} {
		    # if it's a match to the previously selected tile
		    # start counting time
		    $self start-timer
		    # remove the tiles from play
		    $self move-unplace $name1 $slot1 $name2 $slot2
		    # keep history
		    $self history-add $name1 $slot1 $name2 $slot2
		    # keep score
		    $self update-score
		} else {
		    # select the new tile in place of the old one
		    $self set-selected $slot1 $name1
		}
	    } else {
		# just select the new tile
		$self set-selected $slot1 $name1
	    }
	    $self raise-in-render-order
	}
    }
}

#
# create the layout for the "difficult" map tiles, rows, blocks, layers
# each layer of z is drawn offset in x and y to make the tiles stack
# layout is 7 tiles tall in y, plus a bit for the z offset,
# and 11 tiles wide in x, add a tile for margins, so
# take minimum of (width / 12) and ((height / 8) / 1.375)
# (taking aspect h/w = 1.375)
# to decide how large to make the tiles
#
# furthermore, the tiles, rows, and blocks in each layer
# are laid out in render order, which wasn't true in the
# original xml file
#
set mymap {
    {
	layer z 0 parts {
	    {tile x 10 y 3}
	    
	    {block left 8.5 right 9.5 top 0.5 bottom 1.5}
	    {block left 8.0 right 9.0 top 2.5 bottom 3.5}
	    {block left 8.5 right 9.5 top 4.5 bottom 5.5}
	    
	    {row y 0 left 3 right 7}
	    {row y 1 left 2.5 right 7.5}
	    {block left 3.0 right 7.0 top 2.0 bottom 4.0}
	    {row y 5 left 2.5 right 7.5}
	    {row y 6 left 3 right 7}
	    
	    {block left 0.5 right 1.5 top 0.5 bottom 1.5}
	    {block left 1.0 right 2.0 top 2.5 bottom 3.5}
	    {block left 0.5 right 1.5 top 4.5 bottom 5.5}
	    
	    {tile x 0 y 3}
	}
    }
    {
	layer z 1 parts {
	    {tile x 6.5 y 0}
	    
	    {row left 7 right 9 y 1}
	    {block left 7.5 top 2 right 8.5 bottom 4}
	    {row left 7 right 9 y 5}
	    
	    {tile x 6.5 y 6}
	    
	    {row y 0.5 left 4.5 right 5.5}
	    {row y 1.5 left 4 right 6}
	    {block top 2.5 left 3.5 bottom 3.5 right 6.5}
	    {row y 4.5 left 4 right 6}
	    {row y 5.5 left 4.5 right 5.5}
	    
	    {tile x 3.5 y 0}
	    
	    {row left 1 right 3 y 1}
	    {block left 1.5 top 2 right 2.5 bottom 4}
	    {row left 1 right 3 y 5}
	    
	    {tile x 3.5 y 6}
	} 
    }
    {
	layer z 2 parts {
	    {row y 2 left 2.5 right 7.5}
	    {row y 3 left 2 right 8}
	    {row y 4 left 2.5 right 7.5}
	}
    }
    {
	layer z 3 parts {
	    {tile x 7.5 y 3}
	    {block left 3.5 right 6.5 top 2.5 bottom 3.5}
	    {tile x 2.5 y 3}
	}
    }
    {row z 4 left 4 right 6 y 3}
    {row z 5 left 4.5 right 5.5 y 3}
    {tile z 6 x 5 y 3}
}

if {1} {
    # make the fonts bigger
    
    # this by itself should trigger
    # a reselection of fonts at roughly 2x the default size
    # but all it seems to do is change the sizes of windows
    tk scaling 1.0

    # some say that tk scaling should be set from the
    # result of expr {double([winfo screenwidth .])/([winfo screenmmwidth .]/25.40)}
    # however this reports 96 dpi on my pixel, but it also claims I have a 26.6 inch 
    # wide screen with 2560 pixels, but the screen is roughly a foot wide.
    # xrandr -q reports a more realistic screen size

    #this doesn't change anything that I can see
    #font create Font -family Helvetica -size 14
    #option add *.font Font widgetDefault
    # it may be that a global widgetDefault gets overridden by more specific
    # widgetDefault priority settings

    # these on the other hand trigger some
    # larger fonts in Menus and Buttons on some 
    # tk_dialogs
    #
    if {1} {
	set fonts(Helvetica-14) {Menu Label Dialog Message Button Menubutton Checkbutton Radiobutton TLabel TButton TCheckbutton Dialog.msg}
	set fonts(Courier-14) {Entry Text TEntry}
	set fonts(styled) {TButton TCheckbutton}

	foreach font {Helvetica-14 Courier-14} {
	    foreach {fname fsize} [split $font -] break
	    foreach class $fonts($font) {
		# create a named font named $class
		font create $class -family $fname -size $fsize
		# make it the default font of $class widgets
		option add *$class.font $class startupFile
		# if the widget font is styled
		if {$class in $fonts(styled)} {
		    # make $class the default fonta in the style
		    ttk::style config $class -font $class
		}
	    }
	}
	unset fonts font class fname fsize
    }
    # these are the options the tk_dialog pulls its widget width
    # and message font out of
    # option add *Dialog.msg.wrapLength 3i widgetDefault
    # option add *Dialog.msg.font TkCaptionFont widgetDefault
    option add *Canvas.background \#323657 startupFile
}

# create the game window
# with the layout and 
# the tile images for the game
# reload our preferences
# and pass any command line arguments

if {[lsearch $argv {-svg}] >= 0} {
    package require mahjong-svg
    pack [mahjong::canvas .c \
	      -layout [mahjong::layout ::layout -map $mymap] \
	      -tiles [mahjong::tiles ::tiles -svg true -data $::mysvg] \
	      -prefs [mahjong::prefs ::prefs] \
	      {*}$argv \
	     ] -fill both -expand true
} else {
    package require mahjong-png
    pack [mahjong::canvas .c \
	      -layout [mahjong::layout ::layout -map $mymap] \
	      -tiles [mahjong::tiles ::tiles -png true -file [file join $::dir $::mypng]] \
	      -prefs [mahjong::prefs ::prefs] \
	      {*}$argv \
	     ] -fill both -expand true
}

proc trace-puts {msg} { .c trace-puts $msg }
# deal with running inside sdl window
proc viewport-update {x y w h s} {
    trace-puts "viewport-update $x $y $w $h $s"
    wm attributes . -fullscreen true
}
bind . <<ViewportUpdate>> [list viewport-update %x %y %X %Y %s]
trace-puts "sdltk touchtranslate [sdltk touchtranslate 13]"
# sdltk withdraw
sdltk maximize
wm attributes . -zoomed 1
wm attributes . -fullscreen true

# start the first game
.c first-game

