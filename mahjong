#!/usr/bin/wish
# -*- mode: Tcl; tab-width: 8; -*-
#
# Copyright (C) 2016 by Roger E Critchlow Jr, Cambridge, MA, USA.
# 
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
# 

#
# This is a reimplementation of gnome-mahjongg, my preferred time wasting
# solitaire on linux.  For many years I have been annoyed by aspects of
# gnome-mahjongg, but each attempt to deal with the code have been repelled
# by the density of the frameworks used to write the program.  I literally
# could not find the program in its source code, because most of the source
# code is somewhere else in a software framework.  So, I have rewritten 
# the program using Tcl, Tk, and Snit so that all of the source code will
# be apparent to anyone wishing to modify the program.
#
# I will provide only the barest introduction to Tcl, Tk, and Snit because
# you will need other resources if you really want to understand.  Start
# with the online manuals at https://www.tcl.tk/man/ and liberally apply
# google to your problems
#
# Tcl writes function calls in the form
#	func arg arg2
# the result of a function call is captured by square brackets 
#	[func arg arg2]
# variable references are written as
#	$variable
# variable assignment is performed by the set command
#	set variable {1 2 3}
# double quoted text is scanned for command and variable substitution
#	"substitutes $variable and [func arg arg2] in line"
# but curly brace quoted text
#	{does not evaluate $variable or [func arg arg2]}
# Memorizing https://www.tcl.tk/man/tcl8.6/TclCmd/Tcl.htm is a good plan.
#
# Tk uses Tcl to implement graphical user interfaces.  Originally a client 
# of the X11 windowing system on Unix, Tk now happily runs as a native client
# almost everywhere.  Tk user interface widgets are instances given names
#	canvas .name
# the instance name can then be used to set and retrieve configuratio options
#	.name configure -background blue
#	.name cget -background
# or to run methods
#	.name create image
# The manual pages for Tk and the widget-demo.tcl example script will give you
# an overview of the widgets implemented by Tk.  But Mahjong doesn't use much 
# of all that because it is entirely implemented in one Tk canvas widget.
#
# Snit uses Tcl to implement a Tk style object system.  Snit is distributed as
# part of Tcllib, a library implemented entirely in Tcl without use of extensions
# written in C or other high level languages.
#
package require Tcl
package require Tk
package require snit

set ::usetkpath 0
if {$::usetkpath} {
    package require tkpath
}

snit::type mahjong::prefs {
    option -file prefs.tcl
    option -directory -default {} -readonly true
    constructor {args} {
	$self configure {*}$args
    }
    method resolve {file} {
	if {[file isdir [file join ~ .config]]} {
	    set options(-directory) [file join ~ .config mahjong]
	} elseif {[file isdir [file join ~ Library Preferences]]} {
	    set options(-directory) [file join ~ Library Preferences mahjong]
	} elseif {[file isdir [file join ~ {Applications Data}]]} {
	    set options(-directory) [file join ~ {Applications Data} mahjong]
	} else {
	    error "unable to find a preferences directory"
	}
	if { ! [file isdir $options(-directory)]} {
	    file mkdir $options(-directory)
	}
	return [file join $options(-directory) $file]
    }
    method save-prefs {array} {
	if {[catch {
	    set fp [open [$self resolve prefs.tcl] w]
	    puts $fp "array set prefs {"
	    foreach {name value} $array {
		puts $fp [list $name $value]
	    }
	    puts $fp "}"
	    close $fp
	} error]} {
	}
    }
    method load-prefs {} {
	if {[catch {
	    set fp [open [$self resolve prefs.tcl] r]
	    set prefs [read $fp]
	    close $fp
	    if {[string first {array set prefs} $prefs] == 0} {
		eval $prefs
		return [array get prefs]
	    }
	 } error]} {
	     return {}
	 }
    }
    method save-scores {dict} {
	if {[catch {
	    set fp [open [$self resolve scores.tcl] w] 
	    dict for {name value} $dict {
		puts $fp [list $key $value]
	    }
	    close $fp
	} error]} {
	}
    }
    method load-scores {} {
	if {[catch {
	    set dict [dict create]
	    set fp [open [$self resolve scores.tcl] r] 
	    while {[gets $fp line] >= 0} {
		foreach {key value} $line break
		dict set dict $key $value
	    }
	    close $fp
	    return $dict
	} error]} {
	    return $dict
	}
    }
}

snit::type mahjong::layout {
    option -verbose -default 1
    option -map -default {} -configuremethod Configure
    option -layout -readonly true
    option -slots -readonly true
    option -layers -readonly true
    option -rows -readonly true
    option -blocks -readonly true

    constructor {args} {
	if {$options(-verbose) > 5} { puts "$self configure $args" }
	$self configure {*}$args
    }

    # create the layout from a map
    method {Configure -map} {val} {
	if {$options(-verbose) > 5} { puts "$self configure -map $val" }
	set options(-map) $val
	set options(-layout) [dict create]
	set options(-slots) {}
	foreach layer $options(-map) {
	    $self expand-layout $layer
	}
	foreach slot $options(-slots) {
	    $self compute-x-adjacent $slot
	    $self compute-z-shadow $slot
	    #$self compute-left-and-right-rows $slot
	}
	foreach slot $options(-slots) {
	    $self compute-x-closure $slot
	    $self compute-row-closure $slot
	}

    }

    # maintaining slots in the layout
    # the options(-layout) dictionary maps xyz slots to properties
    method set {xyz tag val} { dict set options(-layout) $xyz $tag $val }
    method get {xyz tag} { return [dict get $options(-layout) $xyz $tag] }
    method exists {xyz tag} { return [dict exists $options(-layout) $xyz $tag] }
    method lappend {xyz tag args} { dict with options(-layout) $xyz { lappend $tag {*}$args } }

    # maintaining the primary slot in the layout
    # this is the only one that changes after the layout is setup
    method set-slot {slot val} { $self set $slot slot $val }
    method get-slot {slot} { return [$self get $slot slot] }
    method exists-slot {slot} { return [$self exists $slot slot] }
    method set-empty {slot} { $self set-slot $slot {} }
    method is-empty {slot} { return [expr {[$self get-slot $slot] eq {}}] }
    method is-endcap {xyz} { return [$self get $xyz endcap] }

    proc slot-x {slot} { return [lindex $slot 0] }
    proc slot-y {slot} { return [lindex $slot 1] }
    proc slot-z {slot} { return [lindex $slot 2] }

    # get all of the slots in render order
    # ie, those which are obscured are drawn before those which obscure
    method get-slots {} { return $options(-slots) }
    # find the slots in a z layer in render order
    method layer-slots {z} { return [lmap slot [$self get-slots] {expr {($z == [slot-z $slot]) ? $slot : [continue]}}] }

    # expand the layout map description
    method expand-layout {layout {z 0}} {
	if {$options(-verbose) > 5} { puts "$self expand-layout $layout" }
	set tag [lindex $layout 0]
	array set l [lrange $layout 1 end]
	if {[info exists l(z)]} { set z $l(z) }
	switch $tag {
	    layer {
		foreach p $l(parts) { $self expand-layout $p $z }
	    }
	    tile {
		set row [list [$self add-tile $l(x) $l(y) $z]]
		$self add-row $row
		$self add-block $row
	    }
	    row {
		set row {}
		for {set x $l(right)} {$x >= $l(left)} {set x [expr {$x-1}]} {
		    lappend row [$self add-tile $x $l(y) $z]
		}
		$self add-row $row
		$self add-block $row
	    }
	    block {
		set block {}
		for {set y $l(top)} {$y <= $l(bottom)} {set y [expr {$y+1}]} {
		    set row {}
		    for {set x $l(right)} {$x >= $l(left)} {set x [expr {$x-1}]} {
			lappend row [$self add-tile $x $y $z]
		    }
		    $self add-row $row
		    lappend block {*}$row
		}
		$self add-block $block
	    }
	    default { error "what is $layout doing in the map?" }
	}
    }

    # add the list of slots in a row
    method add-row {row} { foreach slot $row { $self set $slot row $row } }
    # add the list of slots in a block
    method add-block {block} { foreach slot $block { $self set $slot block $block } }
    # mark two cells as x-adjacents, should be x-adjacent, need x-left-adjacent and x-right-adjacent, too
    method add-x-adjacent {xyz xnynzn} { $self add-symmetric x-adjacent $xyz $xnynzn }
    # record a symmetric relation
    method add-symmetric {relation slot1 slot2} {
	# puts "$self add-symmetric $relation {$slot1} {$slot2}a"
	if {[lsearch [$self get $slot1 $relation] $slot2] < 0} {
	    $self lappend $slot1 $relation $slot2
	}
	if {[lsearch [$self get $slot2 $relation] $slot1] < 0} {
	    $self lappend $slot2 $relation $slot1
	}
	# puts "$relation {$slot1} is [$self get $slot1 $relation]"
	# puts "$relation {$slot2} is [$self get $slot2 $relation]"
    }
    # an antisymmetric relation
    method add-left-adjacent {slot1 slot2} {
	if {$slot2 ni [$self get $slot1 left-adjacent]} { $self lappend $slot1 left-adjacent $slot2 }
	if {$slot1 ni [$self get $slot2 right-adjacent]} { $self lappend $slot2 right-adjacent $slot1 }
    }
    method add-right-adjacent {slot1 slot2} { $self add-left-adjacent $slot2 $slot1 }
	
    # add a new tile to the layout
    method add-tile {x y z} {
	# canonicalize the coordinates
	# trouble with x, y in double vs integer as dictionary keys
	set x [expr {double($x)}]
	set y [expr {double($y)}]
	set z [expr {int($z)}]
	if {$options(-verbose) > 5} { puts "add-tile $x $y $z" }
	set xyz [list $x $y $z]
	# initialize slot
	$self set-slot $xyz {}
	foreach {tag val} {x-adjacent {} x-closure {} left-adjacent {} right-adjacent {} z-shadow {} endcap 0} {
	    $self set $xyz $tag $val
	}
	lappend options(-slots) $xyz
	return $xyz
    }

    # compute the x-adjacent set of the tile
    method compute-x-adjacent {xyz} {
	foreach {x y z} $xyz break
	foreach dx {-1 1} {
	    set xn [expr {$x+$dx}]
	    foreach dy {-0.5 0 0.5} {
		set yn [expr {$y+$dy}]
		if { ! [$self exists-slot [list $xn $yn $z]]} continue
		set xnynzn [list $xn $yn $z]
		$self add-x-adjacent $xyz $xnynzn
		if {$xn-$x < 0} {
		    $self add-left-adjacent $xyz $xnynzn
		} else {
		    $self add-right-adjacent $xyz $xnynzn
		}
	    }
	}
	if {[llength [$self left-adjacent $xyz]] == 0 || 
	    [llength [$self right-adjacent $xyz]] == 0} {
	    $self set $xyz endcap 1
	}
    }
    # find the z-shadow cast by this tile on the next layer
    method compute-z-shadow {xyz} {
	foreach {x y z} $xyz break
	set shadow {}
	if {$z > 0} {
	    set x0 [expr {$x-0.5}]
	    set x1 [expr {$x+0.5}]
	    set y0 [expr {$y-0.5}]
	    set y1 [expr {$y+0.5}]
	    foreach slot [$self layer-slots [expr {$z-1}]] {
		foreach {nx ny nz} $slot break
		if {(min($x1,$nx+0.5)-max($x0,$nx-0.5)) > 0 
		    && (min($y1,$ny+0.5)-max($y0,$ny-0.5)) > 0} {
		    lappend shadow $slot
		}
	    }
	}
	$self set $xyz z-shadow $shadow
    }
    method compute-x-closure {xyz} {
	$self set $xyz x-closure [$self compute-relation-closure $xyz x-adjacent]
    }
    method compute-relation-closure {xyz relation} {
	array set closure {}
	set level 1
	set closure($xyz) $level
	set found 1
	while {$found} {
	    set found 0
	    incr level
	    foreach slot [array names closure] {
		if {$closure($slot) != $level-1} continue
		foreach s [$self $relation $slot] {
		    if { ! [info exists closure($s)]} {
			incr found
			set closure($s) $level
		    }
		}
	    }
	}
	# unset closure($xyz)
	return [lsort -real -index 0 [array names closure]]
    }
    # compute the row closure of a slot
    method compute-row-closure {xyz} {
	set rclosure {}
	lappend rowclosure $xyz
	foreach lr {left right} {
	    set closure {}
	    for {set new [$self $lr-adjacent $xyz]} {[llength $new] > 0} {set new $nnew} {
		set nnew {}
		foreach slot $new {
		    if {[lsearch $closure $slot] < 0} {
			lappend closure $slot
			lappend nnew {*}[$self $lr-adjacent $slot]
		    }
		}
	    }
	    lappend rowclosure {*}$closure
	}
	$self set $xyz row-closure [lsort -real -index 0 [lsort -real -index 1 $rowclosure]]
    }

    # return the z-shadow of a slot
    method z-shadow {xyz} { return [$self get $xyz z-shadow] }
    # return the x-adjacent of a slot
    method x-adjacent {xyz} { return [$self get $xyz x-adjacent] }
    # return the x-adjacent closure of a slot
    method x-closure {xyz} { return [$self get $xyz x-closure] }
    # return the left x-adjacent
    method left-adjacent {xyz} { return [$self get $xyz left-adjacent] }
    # return the right x-adjacent
    method right-adjacent {xyz} { return [$self get $xyz right-adjacent] }
    # return the block of the slot
    method block {xyz} { return [$self get $xyz block] }
    # return the row of a slot
    method row {xyz} { return [$self get $xyz row] }
    # return the row closure of a slot
    method row-closure {xyz} { return [$self get $xyz row-closure] }

    # number of empty slots, all filled, or all empty
    method number-empty {slots} { return [tcl::mathop::+ {*}[lmap s $slots {$self is-empty $s}]] }
    method all-filled {slots} {	return [expr {[$self number-empty $slots] == 0}] }
    method all-empty {slots} { return [expr  {[$self number-empty $slots] == [llength $slots]}] }
    method any-filled {slots} { return [expr {[$self number-empty $slots] < [llength $slots]}] }
    # well known slot sets all filled or all empty
    method any-filled-x-adjacent {xyz} { return [$self any-filled [$self x-adjacent $xyz]] } 
    method all-filled-left-adjacent {xyz} { return [$self all-filled [$self left-adjacent $xyz]] }
    method all-filled-right-adjacent {xyz}  { return [$self all-filled [$self right-adjacent $xyz]] }
    method all-empty-left-adjacent {xyz} { return [$self all-empty [$self left-adjacent $xyz]] }
    method all-empty-right-adjacent {xyz}  { return [$self all-empty [$self right-adjacent $xyz]] }
    # can a slot be played
    method can-play {slot} {
	# cannot play an empty slot
	if {[$self is-empty $slot]} { return 0 }
	# cannot play if covered in z
	if {[$self is-covered-in-z $slot]} { return 0 }
	# cannot play if covered in x
	if {[$self is-covered-in-x $slot]} { return 0 }
	return 1
    }
    method is-covered-in-z {slot} {
	foreach s [$self layer-slots [expr {[slot-z $slot]+1}]] {
	    if { ! [$self is-empty $s] && $slot in [$self z-shadow $s]} {
		return 1
	    }
	}
	return 0
    }
    method is-covered-in-x {slot} {
	if {[$self is-endcap $slot]} { return 0 }
	if {[$self all-empty-left-adjacent $slot]} { return 0 }
	if {[$self all-empty-right-adjacent $slot]} { return 0 }
	return 1
    }
    # can a slot be unplayed
    method can-unplay {slot {donotblock {}}} {
	# cannot unplay a filled slot
	if { ! [$self is-empty $slot]} { return 0 }
	# cannot unplay a slot over an empty slot in z
	if {[$self covers-empty-in-z $slot]} { return 0 }
	# cannot unplay a slot over an empty slot in x
	if {[$self covers-empty-in-x $slot]} { return 0 }
	# if donotblock is present, do not play next to or over it
	if {$donotblock ne {}} {
	    # this is the last bug in the game generator, if you
	    # choose the two slots to unplay independently, then
	    # the second can block the first, to be a legal unplay
	    # you have to be able to play the slots in either order
	    if {[$self blocks-in $slot $donotblock]} { return 0 }
	}
	# that was the last bug, but there is another. it is possible to
	# unplay legal moves to a deadlock. so I need to look ahead to
	# choose the best unplayable, or somehow finesse the problem
	return 1;
    }
    #
    method covers-empty-in-z {slot} {
	return [tcl::mathop::+ {*}[lmap s [$self z-shadow $slot] {$self is-empty $s}]]
    }
    #
    method covers-empty-in-x {slot} {
	# Each x-adjacent-closure shall start in one compartment
	# there are ways that multiple seeds could start in 
	# different rows in the compartment and grow together
	# but the growth cannot cross a boundary between different 
	# numbers of rows except when the crossing into row(s) is(are)
	# completely covered by the crossing out of row(s)
	set x [$self x-closure $slot]
	set n [llength $x]
	set ne [tcl::mathop::+ {*}[lmap s $x {$self is-empty $s}]]
	# entirely empty, any slot will do
	if {$ne == $n} { return 0 }
	# one slot left, it will do
	if {$ne == 1} { return 0 }
	# if it is an endcap slot
	if {[$self is-endcap $slot]} {
	    # all neighbors filled, it will do else wait until they're filled
	    if {[$self all-filled [$self x-adjacent $slot]]} { return 0 } else { return 1 }
	}
	# this block is empty, but the closure is not empty
	if {[$self all-empty [$self block $slot]]} {
	    # if all our neighbors to one side are filled, then okay, else not
	    if {[$self all-filled-left-adjacent $slot] || [$self all-filled-right-adjacent $slot]} {
		return 0 } else { return 1 }
	}
	# this block is not empty
	# this row, and its extensions into adjoining blocks are all empty
	# this is the key, isn't it?
	if {[$self all-empty [$self row-closure $slot]]} {
	    # if we are in a block that contains filled slots
	    # but a row that is empty, then any slot in the row
	    # is acceptable, but only if the rows connected to this
	    # row in the closure are empty, too.
	    return 0
	} else {
	    # if we are in a row closure that contains filled slots
	    # then if we are adjacent to a filled slot, okay,
	    # else not okay
	    if {[$self all-filled-left-adjacent $slot]} {
		return 0
	    } elseif {[$self all-filled-right-adjacent $slot]} {
		return 0
	    } 
	    # elseif {[$self any-filled-x-adjacent $slot]} { 
		# okay, maybe if we're partially filled
	        # return 0
	    # }
	    return 1
	}
	error "failed to classify case"
    }
    # does slot $sl1 block in slot $sl2
    method blocks-in {sl1 sl2} {
	# sl1 is on top of sl2 and blocks it in
	if {$sl2 in [$self z-shadow $sl1]} {
	    return 1
	}
	# sl1 is not next to sl2
	if {$sl2 ni [$self x-adjacent $sl1]} {
	    return 0
	}
	# sl2 is free on the other side
	if {[$self is-endcap $sl2]} {
	    return 0
	}
	# sl1 is to the left of sl2
	if {$sl1 in [$self left-adjacent $sl2]} {
	    # and there is nothing to the right
	    return [expr { ! [$self all-empty-right-adjacent $sl2]}]
	}
	# sl1 is to the right of sl2
	# and there is nothing to the left
	return [expr { ! [$self all-empty-left-adjacent $sl2]}]
    }
}

#
# translate a subset of svg into canvas graphics
# make the <defs></defs> in an svg file available
# for rendering as canvas items
#
snit::type mahjong::svg {
    option -file -default {} -readonly true
    option -data -default {} -readonly true
    
    constructor {args} {
	$self configure {*}$args
	if {$options(-data) ne {}} {
	    $self parse $options(-data)
	} elseif {$options(-file) ne {}} {
	    $self parse [read-file $options(-file)]
	} else {
	    error "svg needs -data or -file option specified"
	}
    }

    #
    # read a whole file
    #
    proc read-file {file} {
	set fp [open $file]
	set d [read $fp]
	close $fp
	return $d
    }
    
    #
    # translate an xml format document into a tcl list
    #
    proc xml2list xml {
	regsub -all {>\s*<} [string trim $xml " \n\t<>"] "\} \{" xml
	set xml [string map {> "\} \{#text \{" < "\}\} \{"}  $xml]
	
	set res ""   ;# string to collect the result   
	set stack {} ;# track open tags
	set rest {}
	
	foreach item "{$xml}" {
	    switch -regexp -- $item {
		^# {
		    append res "{[lrange $item 0 end]} " ; #text item
		}
		^/ {
		    regexp {/(.+)} $item -> tagname ;# end tag
		    set expected [lindex $stack end]
		    if {$tagname!=$expected} {error "$item != $expected"}
		    set stack [lrange $stack 0 end-1]
		    append res "\}\} "
		}
		/$ { # singleton - start and end in one <> group
		    regexp {([^ ]+)( (.+))?/$} $item -> tagname - rest
		    set rest [lrange [string map {= " "} $rest] 0 end]
		    append res "{$tagname [list $rest] {}} "
		}
		^!-- { # comment
		}
		default {
		    set tagname [lindex $item 0] ;# start tag
		    set rest [lrange [string map {= " "} $item] 1 end]
		    lappend stack $tagname
		    append res "\{$tagname [list $rest] \{"
		}
	    }
	    if {[llength $rest]%2} {error "att's not paired: $rest"}
	}
	if [llength $stack] {error "unresolved: $stack"}
	string map {"\} \}" "\}\}"} [lindex $res 0]
    }
    
    variable defs -array {}
    variable targets -array {}
    variable defsid {}
    variable immed {}
    
    #
    # translate the svg defining the mahjong tile set
    # into tk::canvas graphics so the tiles can be 
    # generated at appropriate scale for whatever
    # window is used
    #
    ##
    ## interpret transforms
    ##
    # is a 3 element row vector
    proc is-vector {v} {
	return [tcl::mathop::& [expr {[llength $v]==3}] {*}[lmap vi $v {string is double $vi}]]
    }
    # is a 3x3 matrix
    proc is-matrix {m} {
	return [tcl::mathop::& [expr {[llength $m]==3}] {*}[lmap mi $m {is-vector $mi}]]
    }
    # matrix(a b c d e f) as a matrix
    proc abcdef-to-matrix {abcdef} {
	if {[llength $abcdef] != 6} { error "bad abcdef: $abcdef" }
	foreach {a b c d e f} $abcdef break
	return [list [list $a $c $e] [list $b $d $f] {0 0 1}]
    }
    # scale(x y) as a matrix
    proc scale-to-abcdef {x {y {}}} {
	if {$y eq {}} { set y $x }
	return [list $x 0 0 $y 0 0]
    }
    # translate(x y) as a matrix
    proc translate-to-abcdef {x {y 0}} {
	return [list 1 0 0 1 $x $y]
    }
    proc matrix-from-translate {x {y 0}} {
	return [abcdef-to-matrix [translate-to-abcdef $x $y]]
    }
    proc matrix-from-scale {x {y {}}} {
	return [abcdef-to-matrix [scale-to-abcdef $x $y]]
    }
    # vector dot product between vectors written as rows
    proc vector-dot {v1 v2} {
	return [tcl::mathop::+ {*}[lmap x $v1 y $v2 {expr {$x*$y}}]]
    }
    # matrix transpose, only 3x3
    proc matrix-transpose {m} {
	foreach {r1 r2 r3} $m break
	return [lmap x1 $r1 x2 $r2 x3 $r3 {list $x1 $x2 $x3}]
    }
    # matrix times a matrix, each as a column of rows
    proc matrix-mul-matrix {m1 m2} {
	if { ! [is-matrix $m1]} { error "bad matrix: $m1" }
	if { ! [is-matrix $m2]} { error "bad matrix: $m2" }
	return [ lmap m1i $m1 { lmap m2j [matrix-transpose $m2] {vector-dot $m1i $m2j} }]
    }
    # matrix times a column vector written as a row
    proc matrix-mul-vector {m v} {
	return [ lmap mi $m {vector-dot $mi $v} ]
    }
    # matrix as matrix(a b c d e f)
    proc matrix-to-abcdef {matrix} {
	foreach {r1 r2 r3} $matrix break
	foreach {a c e} $r1 break
	foreach {b d f} $r2 break
	foreach {g h i} $r3 break
	if {$g != 0 || $h != 0 || $i != 1} { error "matrix has an unexpected third row {$matrix}" }
	return [list $a $b $c $d $e $f]
    }
    # 
    proc transform-interpret {tag attrs matrix} {
	# matrix(<a> <b> <c> <d> <e> <f>) -> [[a c e] [b d f] [0 0 1]]
	#	[xp]   [a c e]   [xn]
	#	[yp] = [b d f] * [yn]
	#	[ 1]   [0 0 1]   [ 1]
	# translate(<x> [<y>]) == matrix(1 0 0 1 x y) -> [[1 0 x][0 1 y][0 0 1]]
	#	missing <y> then y == 0
	# scale(<x> [<y>]) == matrix(x 0 0 y 0 0) -> [[x 0 0][0 y 0][0 0 1]]
	#	missing <y> then y == x
	# rotate(<a> [<x> <y>]) matrix(cos(a) sin(a) -sin(a) cos(a) 0 0)
	# skewX(<a>) matrix(1 0 tan(a) 1 0 0)
	# skewY(<a>) matrix(1 tan(a) 0 1 0 0)
	#
	# transform1 transform2 are combined by matrix-mul-matrix $transform1 $transform2 
	# the current transformation matrix is the combination of all transforms defined 
	# and it transforms coordinates in the current user coordinate frame into coordinates
	# in the view port coordinate frame.
	#
	array set a $attrs
	if {[info exists a(transform)]} {
	    set tfm $a(transform)
	    set tfm [string map {{,} { }} $tfm]
	    set tfm [regsub -all {  +} $tfm { }]
	    set tfm [string trim $tfm]
	    while {$tfm ne {}} {
		if {[regexp {([a-zA-Z]+)\(([-0-9. ]+)\)(.*)$} $tfm all op args rest]} {
		    set n [llength $args]
		    switch $op {
			matrix {
			    if {$n != 6} {
				error "bad matrix $tfm"
			    }
			    set matrix2 [abcdef-to-matrix $args]
			    set nmatrix [matrix-mul-matrix $matrix $matrix2]
			    #puts "$matrix * matrix($args) -> $nmatrix"
			    set matrix $nmatrix
			}
			translate {
			    if {$n != 1 && $n != 2} {
				error "bad translate $tfm"
			    }
			    set matrix2 [abcdef-to-matrix [translate-to-abcdef {*}$args]]
			    set nmatrix [matrix-mul-matrix $matrix $matrix2]
			    #puts "$matrix * translate($args) -> $nmatrix"
			    set matrix $nmatrix
			}
			scale {
			    if {$n != 1 && $n != 2} {
				error "bad scale $tfm"
			    }
			    set matrix2 [abcdef-to-matrix [scale-to-abcdef {*}$args]]
			    set nmatrix [matrix-mul-matrix $matrix $matrix2]
			    #puts "$matrix * scale($args) -> $nmatrix"
			    set matrix $nmatrix
			}
			rotate {
			    if {$n < 1 || $n > 3} {
				error "bad rotate $tfm"
			    }
			    set nmatrix [matrix-mul-matrix $matrix [rotate-to-matrix {*}$args]]
			    puts "$matrix * rotate($args) -> $nmatrix"
			    set matrix $nmatrix
			}
			skewX {
			    if {$n != 1} {
				error "bad skewX $tfm"
			    }
			    set nmatrix [matrix-mul-matrix $matrix [skewX-to-matrix {*}$args]]
			    puts "$matrix * skewX($args) -> $nmatrix"
			    set matrix $nmatrix
			}
			skewY {
			    if {$n != 1} {
				error "bad skewY $tfm"
			    }
			    set nmatrix [matrix-mul-matrix $matrix [skewY-to-matrix {*}$args]]
			    puts "$matrix * skewY($args) -> $nmatrix"
			    set matrix $nmatrix
			}
			default {
			    error "unimplemented transform: $tfm"
			}
		    }
		    set tfm [string trim $rest]
		}
	    }
	}
	return $matrix
    }
    #
    # path d
    # lower case relative, upper case absolute
    # m or M = move
    # l or L = line
    # h or H = horizontal line
    # v or V = vertical line
    # c or C = cubic bezier 
    # s or S = short cubic bezier
    # q or Q = quartic bezier 
    # t or T = short quartic bezier
    # z or Z = terminate path
    # a or A = elliptical arc
    # numbers with optional spaces and commas
    #
    
    #
    # this just parses all those wierdly concatenated operands into clean lists
    # the additional interpretations available are:
    #  1) rewrite h dx1 dx2 ... to l dx1 0 dx2 0 ...
    #  2) rewrite v dy1 dy2 ... to l 0 dy1 0 dy2 ...
    #  3) rewrite s dcx dcy dx dy ... into c ... by inserting the mirrored control point
    #	(there are relatively few s operations in the tiles)
    #  4) rewrite l concatenated to c by replicating the knot point as control point
    #  5) rewrite m c* z as a smoothed canvas polygon
    #  6) rewrite m c* (anything but z) as a smoothed canvas line
    #	(there are very few of these in the tiles)
    #
    proc path-parse {d} {
	set n [string length $d]
	set cmds {}
	set op {}
	set num {}
	set nums {}
	for {set i 0} {$i < $n} {incr i} {
	    set c [string index $d $i]
	    if {$c in {h H v V l L m M z Z c C q Q s S t T}} {
		if {$num ne {}} { lappend nums $num; set num {} }
		if {$op ne {}} { lappend cmds [list $op {*}$nums]; set nums {} }
		set op $c; set num {}; set nums {}
	    } elseif {$c eq {-}} { # negative sign, only as first character
		if {$num ne {}} { lappend nums $num; set num {} }
		append num $c
	    } elseif {$c in {0 1 2 3 4 5 6 7 8 9 .}} { # part of a number
		if { ! [string is double $num$c]} { lappend nums $num; set num {} }
		append num $c
	    } elseif {[string first $c ", \t\n"] >= 0} { # comma or space or newline, separator
		if {$num ne {}} { lappend nums $num }
		set num {}
	    } else {
		error "unexpected character {$c} in path.d"
	    }
	}
	if {$num ne {}} { lappend nums $num; set num {} }
	if {$op ne {}} { lappend cmds [list $op {*}$nums]; set nums {} }
	return $cmds
    }
    proc path-check-operands {cmds} {
	foreach cmd $cmds {
	    set n [llength [lrange $cmd 1 end]]
	    switch [lindex $cmd 0] {
		m - M { set test {$n == 2} }
		h - v -
		H - V { set test {$n > 0} }
		l - L { set test {$n > 1 && ($n % 2) == 0} }
		s - S { set test {$n > 3 && ($n % 4) == 0} }
		c - C { set test {$n > 5 && ($n % 6) == 0} }
		z - Z { set test {$n == 0} }
		default {
		    error "unexpected command: $cmd"
		}
	    }
	    if { ! [expr $test]} {
		error "wrong number of arguments for: $cmd"
	    }
	}
	return $cmds
    }
    proc path-expand {cmds} {
	
	# translate from abbreviated commands to cubic beziers
	set lop {}
	set lxy {}
	set results {}
	foreach cmd $cmds {
	    set op [lindex $cmd 0]
	    set nresult [lrange $cmd 1 end]; # $result
	    while {1} {
		set result $nresult
		set nresult {}
		switch $op {
		    h { 
			foreach dx $result { lappend nresult $dx 0 }
			set op l
			continue
		    }
		    v {
			foreach dy $result { lappend nresult 0 $dy }
			set op l
			continue
		    }
		    l {
			# it seems that if the desired result is that the desired result
			# is a line from the last point of a cubic bezier, then the last
			# point in the bezier needs to be tripled, too, but because it's
			# relative coordinates, that will be 0 0 0 0 0 0.
			if {$lop eq {c}} { lappend nresult 0 0 0 0 0 0 }
			foreach {dx dy} $result { lappend nresult $dx $dy $dx $dy $dx $dy }
			set op c
			continue
		    }
		    s {
			# this is simplified by the change of coordinate frame.
			# ldc2x ldc2y and ldx ldy are specified relative to llx lly
			# so we can mirror ldcx ldcy through ldx ldy by subtraction,
			# oops, so the prior control point to be mirrored might be
			# in the c string immediately preceding this s string.
			if {$lop eq {c}} {
			    foreach {dc2x dc2y dx dy} [lrange $lxy end-3 end] break
			} elseif {$lop eq {m}} {
			    foreach {dc2x dc2y dx dy} [concat $lxy $lxy] break
			} else {
			    error "unexpected predecessor $lop to s in ..."
			}
			set dc1x [expr {$dx-$dc2x}]
			set dc1y [expr {$dy-$dc2y}]
			foreach {dc2x dc2y dx dy} $result {
			    lappend nresult $dc1x $dc1y $dc2x $dc2y $dx $dy
			    # compute next dc1x and dc1y
			    set dc1x [expr {$dx-$dc2x}]
			    set dc1y [expr {$dy-$dc2y}]
			}
			set op c
			continue
		    }
		    z {
			# close path, hmm, so the path ends c1 c2 k, 
			# but the k should be the same as the m that 
			# that started the path?  Looks like it usually
			# is the m that started the path
			# if {$lop eq {c} && $llop eq {m}} {
			#}
			break
		    }
		    m {
			# in a multi part path, this needs to be relative to
			# to the end of the previous path part, but maybe
			# that happens when we translate to coords from deltas.
		    }
		    c {
			break
		    }
		}
		break
	    }
	    if {$lop eq $op} {
		set lxy [list {*}$lxy {*}$result]
		set results [lreplace $results end end [list $lop {*}$lxy]]
	    } else {
		set lop $op
		set lxy $result
		lappend results [list $op {*}$lxy]
	    }
	    
	}
	return $results
    }
    proc path-translate-xy {xname yname cmd m c} {
	upvar $xname x
	upvar $yname y
	switch $cmd {
	    mc - mcz {
		foreach {dx dy} [lrange $m 1 end] break
		set x [expr {$x+$dx}]
		set y [expr {$y+$dy}]
		lappend cmd $x $y
		foreach {dc1x dc1y dc2x dc2y dx dy} [lrange $c 1 end] {
		    set c1x [expr {$x+$dc1x}]
		    set c1y [expr {$y+$dc1y}]
		    set c2x [expr {$x+$dc2x}]
		    set c2y [expr {$y+$dc2y}]
		    set nx [expr {$x+$dx}]
		    set ny [expr {$y+$dy}]
		    lappend cmd $c1x $c1y $c2x $c2y $nx $ny
		    set x $nx
		    set y $ny
		}
	    }
	    ML {
		foreach {x y} [lrange $m 1 end] break
		lappend cmd $x $y
		foreach {x y} [lrange $c 1 end] {
		    lappend cmd $x $y
		}
	    }
	    default {
		error "unknown cmd {$cmd} in path-translate-xy"
	    }
	}
	return $cmd
    }
    proc path-translate {results} {
	#
	# concatenate mcz and mc into canvas polygon and line items
	# translate from relative to absolute coordinates
	#
	# puts "path d [join [lmap r $results {lindex $r 0}] {}]"
	set cmds {}
	set type [join [lmap r $results {lindex $r 0}] {}];
	set x 0
	set y 0
	while {[llength $results] > 0} {
	    switch -glob $type {
		mcz* {
		    lappend cmds [path-translate-xy x y {mcz} [lindex $results 0] [lindex $results 1]]
		    set results [lrange $results 3 end]
		    set type [string range $type 3 end]
		}
		mc* {
		    lappend cmds [path-translate-xy x y {mc} [lindex $results 0] [lindex $results 1]]
		    set results [lrange $results 2 end]
		    set type [string range $type 2 end]
		}
		ML* {
		    lappend cmds [path-translate-xy x y {ML} [lindex $results 0] [lindex $results 1]]
		    set results [lrange $results 2 end]
		    set type [string range $type 2 end]
		}
		default {
		    error "unexpected type $type"
		}
	    }
	}
	return $cmds
    }
    proc path-interpret {d} {
	set cmds [path-parse $d]
	set cmds [path-check-operands $cmds]
	set cmds [path-expand $cmds]
	return [path-translate $cmds]
    }
    #
    # item generators
    # oh, got the defs/use wrong
    # need to do the translation 
    # at the time of the call so
    # that parameters supplied to
    # the use can be expanded in
    # the call.
    #
    method generate-emit {window matrix code ctags} {
	if {[$self in-defs $ctags]} {
	    # set id [lindex $ctags $i+1]
	    # puts "$ctags implies definition of $id"
	    # lappend defs($id) [list $matrix $code]
	} else {
	    # puts "$ctags implies immediate code"
	    lappend immed [list $matrix $code]
	}
    }
    method generate-frag-finish {window matrix frag ctags} {
	if {[lsearch $frag -width] >= 0} { lappend ctags scale-width }
	lappend frag -tags $ctags
	$self generate-emit $window $matrix $frag $ctags
    }
    method generate-line-finish {window matrix frag fill stroke stroke-width ctags} {
	if {$stroke ne {}} { lappend frag -fill $stroke }
	if {${stroke-width} ne {}} { lappend frag -width ${stroke-width} }
	$self generate-frag-finish $window $matrix $frag $ctags
    }
    method generate-poly-finish {window matrix frag fill stroke stroke-width ctags} {
	if {$fill eq {none}} { set fill {} }
	lappend frag -fill $fill
	if {$stroke ne {}} { lappend frag -outline $stroke }
	if {${stroke-width} ne {}} { lappend frag -width ${stroke-width} }
	$self generate-frag-finish $window $matrix $frag $ctags
    }
    method generate-path {window matrix d fill stroke stroke-width ctags} {
	foreach cmd [path-interpret $d] {
	    set op [lindex $cmd 0]
	    set coords [lrange $cmd 1 end]
	    switch $op {
		mcz { $self generate-poly-finish $window $matrix [list $window create polygon {*}$coords -smooth raw] $fill $stroke ${stroke-width} $ctags }
		mc { $self generate-line-finish $window $matrix [list $window create line {*}$coords -smooth raw] $fill $stroke ${stroke-width} $ctags }
		ML { $self generate-line-finish $window $matrix [list $window create line {*}$coords] $fill $stroke ${stroke-width} $ctags }
		default { error "unknown op $op" }
	    }
	}
    }
    method generate-polygon {window matrix points fill stroke stroke-width ctags} {
	set frag [list $window create polygon {*}$points]
	$self generate-poly-finish $window $matrix $frag $fill $stroke ${stroke-width} $ctags
    }
    method generate-line {window matrix x1 y1 x2 y2 fill stroke stroke-width ctags} {
	set frag [list $window create line $x1 $y1 $x2 $y2]
	$self generate-line-finish $window $matrix $frag $fill $stroke ${stroke-width} $ctags
    }
    method generate-rect {window matrix x y width height fill stroke stroke-width ctags} {
	set frag [list $window create rectangle $x $y [expr {$x+$width}] [expr {$y+$height}]]
	$self generate-poly-finish $window $matrix $frag $fill $stroke ${stroke-width} $ctags
    }
    method generate-circle {window matrix cx cy r fill stroke stroke-width ctags} {
	set frag [list $window create oval [expr {$cx-$r}] [expr {$cy-$r}] [expr {$cx+$r}] [expr {$cy+$r}]]
	$self generate-poly-finish $window $matrix $frag $fill $stroke ${stroke-width} $ctags
    }
    method generate-ellipse {window matrix cx cy rx ry fill stroke stroke-width ctags} {
	set frag [list $window create oval [expr {$cx-$rx}] [expr {$cy-$ry}] [expr {$cx+$rx}] [expr {$cy+$ry}]]
	$self generate-poly-finish $window $matrix $frag $fill $stroke ${stroke-width} $ctags
    }
    method generate-use {window matrix pattrs id ctags} {
	# puts "use $matrix $id $ctags :: $defs($id)"
	if {[$self in-defs $ctags]} {
	    # when in defs section ignore the translation
	} else {
	    # regenerate the code 
	    # puts "use $id -> $defs($id)"
	    foreach {indent c m p tag attrs body} $defs($id) break
	    set pattrs [concat $p $pattrs]
	    set ctags [list {*}$c {*}$ctags]
	    $self element-traverse-one $window $indent $ctags $matrix $pattrs $tag $attrs $body
	}
    }

    #
    # checkers
    #
    variable tags -array {
	svg {
	    ignore-all false
	    can-be-def false
	    require {height width viewBox} ignore {id xmlns:rdf xmlns version xmlns:cc xmlns:xlink xmlns:dc}
	    body-empty false
	}
	metadata {
	    ignore-all false
	    can-be-def false
	    ignore {id}
	    body-empty false
	}
	rdf:RDF	{
	    ignore-all false
	    can-be-def false
	    body-empty false
	}
	cc:Work {
	    ignore-all false
	    can-be-def false
	    ignore rdf:about
	    body-empty false
	}
	dc:format {
	    ignore-all false
	    can-be-def false
	    body-empty false
	}
	\#text {
	    ignore-all true
	}
	dc:type {
	    ignore-all false
	    can-be-def false
	    ignore {rdf:resource}
	    body-empty false
	}
	defs {
	    ignore-all false
	    can-be-def false
	    ignore {id}
	    body-empty false
	}
	g {
	    ignore-all false
	    can-be-def true
	    permit {transform style stroke stroke-width fill x y} ignore {id}
	    body-empty false
	    attr-filler {fill {} stroke {} stroke-width {}}
	}
	path {
	    ignore-all false
	    can-be-def true
	    require {d} permit {id fill stroke stroke-width style}
	    body-empty true
	    attr-filler {fill {} stroke {} stroke-width {}}
	}
	polygon {
	    ignore-all false
	    can-be-def true
	    require {points} permit {stroke stroke-width fill} ignore {id}
	    body-empty true
	    attr-filler {fill {} stroke {} stroke-width {}}
	}
	line {
	    ignore-all false
	    can-be-def true
	    require {x1 y1 x2 y2} permit {fill stroke stroke-width} ignore {id}
	    body-empty true
	    attr-filler {fill {} stroke {} stroke-width {}}
	}
	rect {
	    ignore-all false
	    can-be-def true
	    body-empty true
	    attr-filler {fill {} stroke {} stroke-width {}}
	    require {x y width height} permit {stroke stroke-width fill} ignore {id}
	}
	circle {
	    ignore-all false
	    can-be-def true
	    body-empty true
	    attr-filler {fill {} stroke {} stroke-width {}}
	    require {cx cy r} permit {stroke stroke-width fill} ignore {id}
	}
	ellipse {
	    ignore-all false
	    can-be-def true
	    body-empty true
	    attr-filler {fill {} stroke {} stroke-width {}}
	    require {cx cy rx ry} permit {stroke stroke-width fill} ignore {id}
	}
	use {
	    ignore-all false
	    can-be-def true
	    body-empty true
	    attr-filler {fill {} stroke {} stroke-width {}}
	    require {xlink:href} permit {transform style fill stroke stroke-width x y} ignore {id}
	}
    }
    
    method tag-test {tag test} {
	array set info $tags($tag)
	return $info($test)
    }
    method ignore-all {tag} {
	return [$self tag-test $tag ignore-all]
    }
    method can-be-def {tag} {
	return [$self tag-test $tag can-be-def]
    }
    method attr-check {tag attributes} {
	array set info $tags($tag)
	array set b $attributes
	set missing {}
	foreach treatment {require permit ignore} {
	    if { ! [info exists info($treatment)]} continue
	    set attrs $info($treatment)
	    foreach attr $attrs { 
		set e [info exists b($attr)]
		switch $treatment {
		    require { if {$e} { unset b($attr) } else { lappend missing $attr } }
		    permit { if {$e} { unset b($attr) } }
		    ignore { if {$e} { unset b($attr) } }
		    default { error "unknown attribute treatment: $treatment" }
		}
	    }
	}
	set leftovers [array names b]
	if {$missing ne {} || $leftovers ne {}} {
	    error "attr-check $tag leftovers {$leftovers} missing {$missing}"
	}
    }
    proc attr-filter {attrs} {
	set fattrs {}
	foreach {name value} $attrs {
	    if {$name in {fill stroke stroke-width}} {
		lappend fattrs $name $value
	    }
	}
	return $fattrs
    }
    method body-empty {tag body} {
	if {[$self tag-test $tag body-empty] && $body ne {}} { 
	    error "$tag body is not empty {$body}"
	}
    }
    method interesting-id {tag attrs} {
	array set a $attrs
	if { ! [info exists a(id)]} { return 0 }
	set id $a(id)
	if {[regexp ^$tag\\d+$ $id]} {
	    #puts "$tag id=$id is uninteresting"
	    return 0
	}
	if {$tag eq {path} && [regexp ^circle\\d+$ $id]} {
	    #puts "$tag id=$id is uninteresting"
	    return 0
	}
	if {[info exists targets($id)]} {
	    error "$tag $id already defined as $targets($id)"
	}
	#puts "saving $tag $id"
	set targets($id) $tag
	return 1
    }
    method interesting-target {tag attrs} {
	array set a $attrs
	if { ! [info exists a(xlink:href)]} { error "$tag has no href attribute" }
	set href $a(xlink:href)
	if {[string first \# $href] != 0} { error "$tag href $href does not start with #" }
	set href [string range $href 1 end]
	if { ! [info exists targets($href)]} { error "$tag href $href is not defined" }
	return $href
    }
    proc unpack-style {tag attrs} {
	array set a $attrs
	if {[info exists a(style)]} {
	    switch -regexp $a(style) {
		fill:#[0-9a-f]+ { return [list fill [string range $a(style) 5 end]] }
		stroke:#[0-9a-f]+ { return [list stroke [string range $a(style) 7 end]] }
		default { error "$tag unhandled style $a(style)" }
	    }
	}
	return {}
    }
    method build-attrs {tag attrs pattrs} {
	array set info $tags($tag)
	if {[info exists info(attr-filler)]} {
	    array set a [concat $info(attr-filler) $pattrs $attrs]
	    array set a [unpack-style $tag $attrs]
	} else {
	    array set a [concat $pattrs $attrs]
	}
	return [array get a]
    }
    
    proc lremove {list item} {
	set i [lsearch $list $item]
	if {$i >= 0} {
	    set list [lreplace $list $i $i]
	}
	return $list
    }
    method in-defs {ctags} {
	return [expr {$defsid ne {} && [lsearch $ctags $defsid] >= 0}]
    }
    
    # traverse a document tree $doc
    # using $indent as an indentation string
    # and $ctags as the inherited canvas tags
    # and $pattrs as the inherited attributes
    method element-traverse {window indent ctags matrix pattrs doc} {
	foreach {tag attrs body} $doc {
	    $self element-traverse-one $window $indent $ctags $matrix $pattrs $tag $attrs $body
	}
    }
    method element-traverse-one {window indent ctags matrix pattrs tag attrs body} {
	#element-setup $tag $attrs $body
	# if {$indent in {{} { } {  }}} { puts stdout "$indent$tag $attrs" }
	if {[$self ignore-all $tag]} return
	$self attr-check $tag $attrs
	$self body-empty $tag $body
	array set a [$self build-attrs $tag $attrs $pattrs]
	if {[info exists a(id)] && $a(id) ni $ctags} { lappend ctags $a(id) }
	if {[$self can-be-def $tag] && [$self in-defs $ctags] && [$self interesting-id $tag $attrs]} {
	    set defs($a(id)) [list $indent [lremove $ctags $defsid] $matrix $pattrs $tag $attrs $body]
	}
	switch $tag {
	    svg -
	    metadata -
	    rdf:RDF -
	    cc:Work -
	    dc:format -
	    dc:type {}
	    defs { 
		set defsid $a(id)
	    }
	    g {
		set matrix [transform-interpret $tag $attrs $matrix]
		set pattrs [attr-filter [array get a]]
	    }
	    path {
		$self generate-path $window $matrix $a(d) $a(fill) $a(stroke) $a(stroke-width) $ctags
	    }
	    polygon {
		$self generate-polygon $window $matrix $a(points) $a(fill) $a(stroke) $a(stroke-width) $ctags
	    }
	    line {
		$self generate-line $window $matrix $a(x1) $a(y1) $a(x2) $a(y2) $a(fill) $a(stroke) $a(stroke-width) $ctags
	    }
	    rect {
		$self generate-rect $window $matrix $a(x) $a(y) $a(width) $a(height) $a(fill) $a(stroke) $a(stroke-width) $ctags
	    }
	    circle {
		$self generate-circle $window $matrix $a(cx) $a(cy) $a(r) $a(fill) $a(stroke) $a(stroke-width) $ctags
	    }
	    ellipse {
		$self generate-ellipse $window $matrix $a(cx) $a(cy) $a(rx) $a(ry) $a(fill) $a(stroke) $a(stroke-width) $ctags
	    }
	    use {
		# call definition
		set x 0; if {[info exists a(x)]} { set x $a(x) }
		set y 0; if {[info exists a(y)]} { set y $a(y) }
		set matrix [transform-interpret $tag $attrs $matrix]
		if {$x != 0 || $y != 0} {
		    set matrix [matrix-mul-matrix $matrix [matrix-from-translate $x $y] ]
		}
		set id [$self interesting-target $tag $attrs]
		$self generate-use $window $matrix [attr-filter [array get a]] $id $ctags
	    }
	    default {
		puts stderr "missing tag $tag"
	    }
	}
	foreach item $body { $self element-traverse $window "$indent " $ctags $matrix $pattrs $item }
    }

    #
    # parse an svg document
    #
    method parse {doc} {
	$self element-traverse .svg {} {} [abcdef-to-matrix {1 0 0 1 0 0}] {} [xml2list $doc] 
    }
    method defs {{pattern *}} {
	return [array names defs $pattern]
    }
    method draw-immed {window} {
	foreach record $immed {
	    foreach {matrix code} $record break
	    set abcdef [matrix-to-abcdef $matrix]
	    set cid [{*}$code]
	    # puts "$cid <- $code"
	    set xscale [lindex $abcdef 0]
	    set yscale [lindex $abcdef 3]
	    set xmove [lindex $abcdef 4]
	    set ymove [lindex $abcdef 5]
	    $window scale $cid 0 0 $xscale $yscale
	    $window move $cid $xmove $ymove
	    if {[lsearch [$window itemcget $cid -tags] scale-width] >= 0} {
		set width [$window itemcget $cid -width]
		$window itemconfigure $cid -width [expr {$xscale*$width}]
		# puts "$cid [$window itemcget $cid -tags] $width -> [expr {$xscale*$width}]"
	    }
	}	
    }
    method draw {window svgid x y sx sy ctag} {
	set immed {}
	set matrix [matrix-mul-matrix [matrix-from-translate $x $y] [matrix-from-scale $sx $sy]]
	$self generate-use $window $matrix {} $svgid $ctag
	$self draw-immed $window
	return $ctag
    }
}

#
# I currently render the tiles svg file into a png using inkscape. The svg renders into
# an image with two rows of 44 tiles each.  The top row contains the unselected images 
# and the bottom row the selected images.  The list initializing the -tiles option below
# gives the names of the tiles.
#
# This set of tile images includes a spare white dragon, one drawn with Ubuntu branding 
# and the other rendering as a blank white tile.  A complete game set includes four of 
# each tile except for the seasons and flowers bonus tiles, which are each a set of four
# as they come.
#
# The mahjong::tiles type runs inkscape to create an appropriately sized image and then
# splits the tile images out of the resulting png.  It would be better to generate the
# images without the use of inkscape.  A full set of game tile names are defined and the
# appropriate tile images are associated with each tile name.
#
snit::type mahjong::tiles {
    option -svg -readonly true
    option -width -readonly true
    option -height -readonly true
    option -tiles -readonly true -default {
	one-coin two-coins three-coins four-coins five-coins six-coins seven-coins eight-coins nine-coins
	north-wind west-wind south-wind east-wind red-dragon green-dragon
	one-character two-character three-character four-character five-character six-character seven-character eight-character nine-character 
	one-bamboo two-bamboo three-bamboo four-bamboo five-bamboo six-bamboo seven-bamboo eight-bamboo nine-bamboo 
	season-1 season-2 season-3 season-4 white-dragon flower-1 flower-2 flower-3 flower-4 {}
    }
    option -pieces -readonly true
    option -normal -readonly true
    option -select -readonly true

    variable map [dict create]

    component svg

    constructor {args} {
	$self configure {*}$args

	set n [llength $options(-tiles)]
	set twid $options(-width)
	set thgt [expr {$twid*11/8}]
	set options(-height) $thgt
	set svg [mahjong::svg $self.svg -file $options(-svg)]
	set options(-normal) {}
	set options(-select) {}
	for {set i 0} {$i < $n} {incr i} {
	    set name [lindex $options(-tiles) $i]
	    if {$name ne {}} {
		switch -glob $name {
		    season-* - flower-* { set card 1 }
		    default { set card 4 }
		}
		for {set j 1} {$j <= $card} {incr j} {
		    set tname "$name#$j"
		    dict set map $tname name $name
		    if {$card == 4} {
			dict set map $tname match $name
		    } else {
			dict set map $tname match [string range $name 0 end-2]
		    }
		}
	    }
	}
    }
    # tiles returns a complete tile set, list of name#instance
    method get-tiles {} { return [dict keys $map] }
    # normal returns the normal image for a tile
    method normal {name} { return [list plain-$name face-$name] } 
    # select returns the selected image for a tile
    method select {name} { return [list selected-$name face-$name] } 
    # match tests if the first tile matches the second tile
    method match {name1 name2} { return [expr {[dict get $map $name1 match] eq [dict get $map $name2 match]}] }
    # draw a tile
    method draw {window tile x y s} {
	$svg draw $window selected-tile $x $y $s $s [list $tile selected]
	$svg draw $window plain-tile $x $y $s $s [list $tile plain]
	$svg draw $window [dict get $map $tile name] $x $y $s $s [list $tile face]
    }
}

snit::widgetadaptor mahjong::canvas {
    option -layout -readonly true
    option -tiles -readonly true
    option -prefs -readonly true
    option -shuffled-tiles -readonly true
    option -shuffled-slots -readonly true
    option -offsets -default {0 0} -readonly true
    option -trace false

    option -title mahjong
    option -game -default 0
    option -start-timer 0
    option -remaining-moves 0
    option -remaining-tiles 0
    
    component layout
    component tiles

    delegate option -width to tiles
    delegate option -height to tiles

    delegate method get-tiles to tiles
    delegate method match to tiles

    delegate method set-slot to layout
    delegate method set-empty to layout
    delegate method get-slot to layout
    delegate method get-slots to layout
    delegate method is-empty to layout
    delegate method is-endcap to layout
    delegate method z-shadow to layout
    delegate method x-adjacent to layout
    # delegate method x-closure to layout
    delegate method can-unplay to layout
    delegate method can-play to layout
    
    delegate option * to hull
    delegate method * to hull
    
    variable data [dict create selected {} paused false]
    
    constructor {args} {
	if {$::usetkpath} {
	    installhull using ::tkp::canvas
	} else {
	    installhull using ::canvas
	}
	bind $win <Configure> [mymethod adjust-window]
	bind $win <Button-3> [list {*}[mymethod menu-popup] %W %x %y]
	$self configure {*}$args

	$self menu-build
	
	set layout $options(-layout)
	set tiles $options(-tiles)
	
	set twid [$self cget -width]
	set thgt [$self cget -height]
	
	# foreach name [$self get-tiles] { }
	
	if {$options(-game) ne {0}} {
	    $self new-game [scan-game $options(-game)]
	} else {
	    $self new-game [clock seconds]
	}
    }
    
    method set-name {name slot} { dict set data name-to-slot $name $slot }
    method get-name {name} { return [dict get $data name-to-slot $name] }

    method get-remaining-tiles {} {
	return [lmap name [$self get-tiles] {expr {[$self get-name $name] ne {}?$name:[continue]}}]
    }

    # context menu, button 3 or 2 on the background
    # with single character accelerators on the root window
    method menu-build {} {
	# popup menu
	menu .m -tearoff no
	set accels {}
	foreach record {
	    {command n {New Game} new-game}
	    {command o {Restart} restart-game}
	    {separator}
	    {command p {Pause} pause-game}
	    {command c {Continue} continue-game}
	    {separator}
	    {command h {Hint} hint}
	    {command u {Undo} undo}
	    {command r {Redo} redo}
	    {separator}
	    {hint m {Menu} menu-menu}
	    {command s {Scores} scores}
	    {command f {Preferences} preferences}
	    {command ? {Help} help}
	    {separator}
	    {command b {By Name} by-name}
	    {separator}
	    {command q {Quit} quit}
	} {
	    foreach {entry accelerator label meth var} $record break
	    if {$record ne {separator}} {
		if {[lsearch -exact $accels $accelerator] >= 0} { error "duplicate accelerator for $record" }
		lappend accels $accelerator
	    }
	    switch $entry {
		separator {
		    .m add separator
		}
		command {
		    .m add command -accelerator $accelerator -label $label -command [mymethod $meth]
		    if {$accelerator eq {?}} { set accelerator question }
		    bind . <KeyPress-$accelerator> [list {*}[mymethod menu-protect] $label $meth]
		}
		checkbutton {
		    .m add checkbutton -accelerator $accelerator -label $label -variable [myvar $var]
		    bind . <KeyPress-$accelerator> [list {*}[mymethod menu-protect] $label $meth]
		}
		hint {
		    .m add command -accelerator $accelerator -label $label
		    bind . <KeyPress-$accelerator> [mymethod $meth]
		}
		default {
		    error "unexpected menu entry command $entry"
		}
	    }
	}
    }
    # popup the menu when we are over the background
    method menu-popup {w x y} {
	if {[$win find withtag current] eq {}}  { tk_popup .m $x $y }
    }
    # enable and disable lists of menu entries
    method menu-enable-disable {enable disable} {
	foreach label $enable { .m entryconfigure $label -state normal }
	foreach label $disable { .m entryconfigure $label -state disabled }
    }
    # protect an accelerator from calling the entry function when disabled
    method menu-protect {label meth} {
	# puts "$self menu-protect $label $meth"
	if {[.m entrycget $label -state] eq {normal}} {
	    $self $meth
	}
    }
    
    ##
    ## menu functions
    ##
    method new-game {{game {}}} {
	$self setup $game
	while {[catch {$self restart} error]} {
	    if {$error eq {cannot unplay}} {
		# puts "$error\n$::errorInfo"
		set options(-shuffled-slots) [shuffle $options(-shuffled-slots)]
		puts "retrying new game"
	    } else {
		puts "$error\n$::errorInfo"
		set options(-shuffled-slots) [shuffle $options(-shuffled-slots)]
		puts "retrying new game"
	    }
	}
    }
    method restart-game {} { $self restart }
    method pause-game {} {
	$self clear-selected
	dict set data paused true
	foreach tile [$self get-remaining-tiles] { $self show [$self get-name $tile] $tile blank }
	$self menu-enable-disable {{Continue}} {{New Game} {Restart} {Pause} {Hint} {Undo} {Redo} {Scores} {Preferences} {Help}}
    }
    method continue-game {} {
	$self menu-enable-disable {{New Game} {Restart} {Pause} {Hint} {Undo} {Redo} {Scores} {Preferences}} {{Continue}}
	foreach tile [$self get-remaining-tiles] { $self show [$self get-name $tile] $tile plain }
	dict set data paused false
    }
    method hint {} {
	set slots [concat {*}[$self find-moves]]
	if {$slots ne {}} {
	    dict incr data hint
	    set slot [lindex $slots [expr {[dict get $data hint]%[llength $slots]}]]
	    $self set-selected $slot [$self get-slot $slot]
	}
    }
    method undo {} { $self history-undo }
    method redo {} { $self history-redo }
    
    method menu-menu {} { $self menu-popup . 100 100 }
    
    method scores {} {}
    method preferences {} {}
    method help {} { puts "help called" }
    method by-name {} {
	toplevel .b
	wm title .b {By Name}
	grid [ttk::label .b.l -text {Choose game by name}] -row 1 -column 0 -columnspan 2 -sticky ew 
	grid [ttk::entry .b.e] -row 2 -column 0 -columnspan 2 -sticky ew
	.b.e insert end [format-game $options(-game)]
	grid [ttk::button .b.okay -text Okay -command [list {*}[mymethod by-name-finish] okay]] -row 3 -column 0 -sticky ew
	grid [ttk::button .b.cancel -text Cancel -command [list {*}[mymethod by-name-finish] cancel]] -row 3 -column 1 -sticky ew
	
    }
    method by-name-finish {how} {
	if {$how eq {okay}} { set options(-game) [scan-game [.b.e get]] }
	destroy .b
	$self new-game $options(-game)
    }
	
    method quit {} { destroy . }
    
    ##
    ## window display helpers
    ##
    method inverted-offsets {} {
	if {$options(-offsets) eq {}} { set options(-offsets) {0 0} }
	return [lmap a $options(-offsets) {expr {-$a}}]
    }
    
    # compute the xoff yoff that centers the current 
    method adjust-window {} {
	#$win move all {*}[$self inverted-offsets]
	foreach {x1 y1 x2 y2} [$win bbox all] break
	set w [winfo width $win]
	set h [winfo height $win]
	set xoff [expr {(($w-($x2-$x1))/2) - $x1}]
	set yoff [expr {(($h-($y2-$y1))/2) - $y1}]
	#$win move all $xoff $yoff
	set options(-offsets) [list $xoff $yoff]
    }
    
    
    ##
    ## game play helpers
    ##
    method get-items {} { return $options(-items) }
    
    proc shuffle {oldlist} {
	set n [llength $oldlist]
	set list $oldlist
	for {set i 0} {$i < $n} {incr i} {
	    set j [expr {$i+int(rand() * ($n-$i))}]
	    if {$i != $j} {
		set li [lindex $list $i]
		set lj [lindex $list $j]
		set list [lreplace [lreplace $list $j $j $li] $i $i $lj]
	    }
	}
	return $list
    }
    
    method sort-matching {names} {
 	set sort {}
 	while {[llength $names] > 0} {
 	    set name1 [lindex $names 0]
 	    set names [lrange $names 1 end]
 	    lappend sort $name1
 	    for {set n2 0} {$n2 < [llength $names]} {incr n2} {
 		set name2 [lindex $names $n2]
 		if {[$self match $name1 $name2]} {
 		    lappend sort $name2
 		    set names [lreplace $names $n2 $n2]
 		    break
 		}
 	    }
 	}
 	# puts [lmap i $sort {$self item-to-name $i}]
 	return $sort
    }
    
    method raise-in-render-order {} {
	foreach slot [$self get-slots] {
	    $win raise [$self get-slot $slot]
	}
    }
    
    ##
    ## window title bar status
    ##
    method start-status {} {
	if { ! [dict exists $data status-started]} {
	    dict set data status-started [after 100 [list {*}[mymethod update-status]]]
	}
    }
    
    method update-status {} {
	set gname [format-game $options(-game)]
	if {$options(-start-timer) == 0} {
	    set elapsed 0
	} else {
	    set elapsed [expr {[clock seconds] - $options(-start-timer)}]
	}
	set elapsed [format {%d:%02d} [expr {$elapsed/60}] [expr {$elapsed%60}]]
	wm title . "$options(-title) - $gname - $elapsed - $options(-remaining-moves) moves, $options(-remaining-tiles) tiles"
	dict set data status-started [after 100 [list {*}[mymethod update-status]]]
    }
    
    method start-timer {} {
	if {$options(-start-timer) == 0} { set options(-start-timer) [clock seconds] }
    }
    
    method update-score {} {
	set options(-remaining-moves) [$self count-moves]
    }
    
    method count-moves {} {
	return [llength [$self find-moves]]
    }
    
    proc format-game {game} {
	while {$game != 0} {
	    set c [expr {$game%26}]
	    set game [expr {$game/26}]
	    lappend format [lindex {a b c d e f g h i j k l m n o p q r s t u v w x y z} $c]
	}
	return [join [lreverse $format] {}]
    }
    
    proc scan-game {game} {
	set n 0
	foreach c [split $game {}] {
	    set n [expr {$n*26+[lsearch {a b c d e f g h i j k l m n o p q r s t u v w x y z} $c]}]
	}
	return $n
    }
    
    ##
    ## history maintenance
    ##
    method history-empty {} {
	dict set data history [dict create {*}{
	    count 0
	    future 0
	    items {}
	}]
	dict with data history {
	    $self menu-enable-disable {} {Undo Redo}
	}
    }
    method history-save-reversed {} {
	dict with data history {
	    return [dict create count 0 future $future items [lreverse $items]]
	}
    }
    method history-restore {old} {
	$self clear-selected
	dict set data history $old
	dict with data history {
	    if {$count < $future} {
		$self menu-enable-disable {Undo Redo} {}
	    } else {
		$self menu-enable-disable {Undo} {Redo}
	    }
	}
    }
    method history-get-count {} { return [dict get $data history count] }
    method history-get-future {} { return [dict get $data history future] }
    method history-get-items {} { return [dict get $data history items] }
    method history-add {nm1 sl1 nm2 sl2} {
	$self clear-selected
	incr options(-remaining-tiles) -2
	dict with data history {
	    if {[llength $items] > $count} {
		set items [lrange $items 0 $count-1]
	    }
	    lappend items [list $nm1 $sl1 $nm2 $sl2]
	    incr count 1
	    set future $count
	    $self menu-enable-disable {Undo} {Redo}
	}
    }
    method history-undo {} {
	# step back
	$self clear-selected
	incr options(-remaining-tiles) 2
	dict with data history {
	    incr count -1
	    $self move-undo {*}[lindex $items $count]
	    if {$count > 0} {
		$self menu-enable-disable {Undo Redo} {}
	    } else {
		$self menu-enable-disable {Redo} {Undo}
	    }
	}
    }
    method history-redo {} {
	# step forward
	$self clear-selected
	incr options(-remaining-tiles) -2
	dict with data history {
	    $self move-redo {*}[lindex $items $count]
	    incr count 1
	    if {$count < $future} {
		$self menu-enable-disable {Undo Redo} {}
	    } else {
		$self menu-enable-disable {Undo} {Redo}
	    }
	}
    }
    
    method move-undo {name1 slot1 name2 slot2} {
	$self tile-place $slot1 $name1
	$self tile-place $slot2 $name2
    }
    method move-redo {name1 slot1 name2 slot2} {
	$self tile-unplace $slot1 $name1
	$self tile-unplace $slot2 $name2
    }
    
    ##
    ## setup the next game
    ##
    method setup {{game {}}} {
	# set up for a new game which might be restarted
	# so, game number seeds random number generator, 
	# results in shuffle of -slots and -tiles
	# the optional $game may be supplying a game by name
	# or simply the time
	if {$game eq {}} { set game [clock seconds] }
	set options(-game) $game
	expr {srand($options(-game))}
	set options(-shuffled-slots) [shuffle [$self get-slots]]
	set options(-shuffled-tiles) [$self sort-matching [shuffle [$self get-tiles]]]
	$self start-status
    }
    
    ##
    ## start or restart the currently setup game
    ##
    method restart {} {
	# reset timer
	set options(-start-timer) 0
	# clear selection
	$self clear-selected
	# empty slots
	foreach slot [$self get-slots] { 
	    set name [$self get-slot $slot]
	    if {$name ne {}} {
		$self tile-unplace $slot $name
	    }
	    $self set-empty $slot 
	}
	# reset images
	foreach name [$self get-tiles] { $self set-name $name {} }
	
	# pick matching pairs from available
	set names $options(-shuffled-tiles)
	set slots $options(-shuffled-slots)
	set moves {}
	
	while {[llength $names]} {
	    set options(-remaining-tiles) [llength $names]
	    
	    ## choose the pair of matched tiles to play
	    # take first and second tiles in name list
	    foreach {name1 name2} $names break
	    set names [lrange $names 2 end]
	    
	    # take first open slot in slot list
	    set slot1 [$self find-can-unplay $slots]
	    set s1 [lsearch $slots $slot1]
	    set slots [lreplace $slots $s1 $s1]

	    # put the first tile in its slot
	    $self tile-place $slot1 $name1
	    lappend moves $name1 $slot1
	    # take next open slot in slot list
	    # but avoid slots that block $slot1
	    set slot2 [$self find-can-unplay $slots $slot1]
	    set s2 [lsearch $slots $slot2]
	    set slots [lreplace $slots $s2 $s2]
	    
	    # put the second tile in its slot
	    $self tile-place $slot2 $name2
	    
	    # make backwards history
	    lappend moves $name2 $slot2
	    
	    # test for forward playability
	    if { ! [$self can-play $slot1]} {
		error "proposed move slot1 $slot1 cannot play"
	    } elseif { ! [$self can-play $slot2]} {
		error "proposed move slot2 $slot2 cannot play"
	    } elseif { ! [$self match $name1 $name2]} {
		error "proposed move mismatches $nm1 and $nm2"
	    }
	}

	# make and save the history of the play
	# this allows the construction of the deal to be played in reverse
	# at the start of each game by redoing moves
	$self history-empty
	foreach {name1 slot1 name2 slot2} $moves {
	    $self history-add $name1 $slot1 $name2 $slot2
	}
	$self history-restore [$self history-save-reversed]
	
	# raise slots in render order
	$self raise-in-render-order
	
	# adjust window
	$self adjust-window
	
	# compute
	set options(-remaining-tiles) [llength [$self get-remaining-tiles]]
	set options(-remaining-moves) [$self count-moves]
    }
    
    ##
    ## game play/unplay mechanics
    ##
    method find-slots-in-play {} {
	return [lmap s [$self get-slots] {expr {[$self is-empty $s]?[continue]:$s}}]
    }
    method find-moves {} {
	set moves {}
	set slots [$self find-slots-in-play]
	set slots [$self find-all-can-play $slots]
	for {set i 0} {$i < [llength $slots]} {incr i} {
	    set si [lindex $slots $i]
	    set ni [$self get-slot $si]
	    for {set j [expr {$i+1}]} {$j < [llength $slots]} {incr j} {
		set sj [lindex $slots $j]
		set nj [$self get-slot $sj]
		if {[$self match $ni $nj]} {
		    lappend moves [list $si $sj]
		}
	    }
	}
	return $moves
    }
    
    method find-can-unplay {slots {donotblock {}}} {
	foreach slot $slots {
	    if {[$self can-unplay $slot $donotblock]} { return $slot }
	}
	error "cannot unplay"
    }
    method find-all-can-unplay {slots {donotblock {}}} {
	return [lmap slot $slots {
	    expr {[$self can-unplay $slot $donotblock] ? $slot : [continue]}
	}]
    }
    method find-can-play {slots} {
	foreach slot $slots {
	    if {[$self can-play $slot]} { return $slot }
	}
	error "cannot play"
    }
    method find-all-can-play {slots} {
	return [lmap slot $slots {
	    expr {[$self can-play $slot] ? $slot : [continue]}
	}]
    }
    ##
    ##
    ##
    method draw {slot name} {
	set twid [$self cget -width];   # tile width
	set thgt [$self cget -height];  # tile height
	set xstep [expr {$twid/10.0}];  # offset for 3d border
	set ystep [expr {$thgt/10.0}];  # offset for 3d border
	set fwid [expr {$twid-$xstep}];	# tile face width
	set fhgt [expr {$thgt-$ystep}];	# tile face height
	foreach {x y z} $slot break;	# slot
	set x [expr {(3.5+$x)*$fwid + $z*$xstep}]
	set y [expr {(0.5+$y)*$fhgt - $z*$ystep}]
	if {[$win find withtag $name] eq {}} {
	    $tiles draw $win $name $x $y [expr {$twid/64.0}]
	} else {
	    foreach {ox oy} [dict get $data coords $name] break
	    $win move $name [expr {$x-$ox}] [expr {$y-$oy}]
	}
	dict set data coords $name [list $x $y]
    }
    method show {slot name tag} {
	foreach id [$win find withtag $name] {
	    set tags [$win itemcget $id -tags]
	    switch $tag {
		plain -
		selected {
		    if {[lsearch $tags $tag] >= 0 || [lsearch $tags face] >= 0} {
			$win itemconfigure $id -state normal
		    } else {
			$win itemconfigure $id -state hidden
		    }
		}
		blank {
		    if {[lsearch $tags plain] >= 0} {
			$win itemconfigure $id -state normal
		    } else {
			$win itemconfigure $id -state hidden
		    }
		}
	    }
	}
    }
    method hide {slot name} {
 	$win itemconfigure $name -state hidden
    }
    ##
    ##
    ##
    method tile-place {slot name} {
	#puts "$self tile-place $slot $name $draw"
	$self set-slot $slot $name
	$self set-name $name $slot
	$self draw $slot $name
	$self show $slot $name plain
	$win bind $name <Enter> [list {*}[mymethod enter] $slot $name]
	$win bind $name <Leave> [list {*}[mymethod leave] $slot $name]
	$self raise-in-render-order
    }
    
    method tile-unplace {slot name} {
 	$self set-name $name {}
	$self set-empty $slot
	$self hide $slot $name
    }
    method tile-is-placed {slot name} {
	return [expr {[$self get-slot $slot] eq $name}]
    }
    ##
    ## tile mouse event handlers
    ## mostly concerned with selected tile management
    ## set-selected {slot name}
    ##
    method get-selected {} { return [dict get $data selected] }
    method is-selected {} { return [expr {[$self get-selected] ne {}}] }
    method clear-selected {} {
	if {[$self is-selected]} { $self show {*}[$self get-selected] plain }
	dict set data selected {}
    }
    method set-selected {args} { 
	$self clear-selected
	if {$args ne {}} { $self show {*}$args selected	}
	dict set data selected $args
    }
    
    method enter {slot name} { $win bind $name <Button-1> [list {*}[mymethod button] $slot $name] }
    method leave {slot name} { $win bind $name <Button-1> {} }
    
    method button {slot1 name1} {
	if {[dict get $data paused]} return
	# if the tile is playable
	if {[$self can-play $slot1]} {
	    # if there's an already selected tile
	    if {[$self is-selected]} {
		# get the selected tile and clear the selection
		foreach {slot2 name2} [$self get-selected] break
		$self clear-selected
		if {$name1 eq $name2} {
		    # if it's the same tile
		    # just return, we've cancelled the selection
		    # and undone the selected image
		} elseif {[$self match $name1 $name2]} {
		    # if it's a match to the previously selected tile
		    # start counting time
		    $self start-timer
		    # remove the tiles from play
		    $self move-redo $name1 $slot1 $name2 $slot2
		    # keep history
		    $self history-add $name1 $slot1 $name2 $slot2
		    # keep score
		    after 0 [list {*}[mymethod update-score]]
		} else {
		    # select the new tile in place of the old one
		    $self set-selected $slot1 $name1
		}
	    } else {
		# just select the new tile
		$self set-selected $slot1 $name1
	    }
	    $self raise-in-render-order
	}
    }
}

#
# create the layout for the "difficult" map tiles, rows, blocks, layers
# each layer of z is drawn offset in x and y to make the tiles stack
# layout is 7 tiles tall in y, plus a bit for the z offset,
# and 11 tiles wide in x, add a tile for margins, so
# take minimum of (width / 12) and ((height / 8) / 1.375)
# (taking aspect h/w = 1.375)
# to decide how large to make the tiles
#
# furthermore, the tiles, rows, and blocks in each layer
# are laid out in render order, which wasn't true in the
# original xml file
#
set mymap {
    {
	layer z 0 parts {
	    {tile x 10 y 3}
	    
	    {block left 8.5 right 9.5 top 0.5 bottom 1.5}
	    {block left 8.0 right 9.0 top 2.5 bottom 3.5}
	    {block left 8.5 right 9.5 top 4.5 bottom 5.5}
	    
	    {row y 0 left 3 right 7}
	    {row y 1 left 2.5 right 7.5}
	    {block left 3.0 right 7.0 top 2.0 bottom 4.0}
	    {row y 5 left 2.5 right 7.5}
	    {row y 6 left 3 right 7}
	    
	    {block left 0.5 right 1.5 top 0.5 bottom 1.5}
	    {block left 1.0 right 2.0 top 2.5 bottom 3.5}
	    {block left 0.5 right 1.5 top 4.5 bottom 5.5}
	    
	    {tile x 0 y 3}
	}
    }
    {
	layer z 1 parts {
	    {tile x 6.5 y 0}
	    
	    {row left 7 right 9 y 1}
	    {block left 7.5 top 2 right 8.5 bottom 4}
	    {row left 7 right 9 y 5}
	    
	    {tile x 6.5 y 6}
	    
	    {row y 0.5 left 4.5 right 5.5}
	    {row y 1.5 left 4 right 6}
	    {block top 2.5 left 3.5 bottom 3.5 right 6.5}
	    {row y 4.5 left 4 right 6}
	    {row y 5.5 left 4.5 right 5.5}
	    
	    {tile x 3.5 y 0}
	    
	    {row left 1 right 3 y 1}
	    {block left 1.5 top 2 right 2.5 bottom 4}
	    {row left 1 right 3 y 5}
	    
	    {tile x 3.5 y 6}
	} 
    }
    {
	layer z 2 parts {
	    {row y 2 left 2.5 right 7.5}
	    {row y 3 left 2 right 8}
	    {row y 4 left 2.5 right 7.5}
	}
    }
    {
	layer z 3 parts {
	    {tile x 7.5 y 3}
	    {block left 3.5 right 6.5 top 2.5 bottom 3.5}
	    {tile x 2.5 y 3}
	}
    }
    {row z 4 left 4 right 6 y 3}
    {row z 5 left 4.5 right 5.5 y 3}
    {tile z 6 x 5 y 3}
}

# create the game window
# with the layout and 
# the tile images for the game
# this is a tile width that works at 2560x1700 

set width 165
pack [mahjong::canvas .c -background \#323657 \
	  -layout [mahjong::layout ::layout -map $mymap] \
	  -tiles [mahjong::tiles ::tiles -svg postmodern.svg -width $width] {*}$argv \
	  -prefs [mahjong::prefs ::prefs] \
	 ] -fill both -expand true
