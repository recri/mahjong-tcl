#!/usr/bin/wish
# -*- mode: Tcl; tab-width: 8; -*-
#
# Copyright (C) 2016 by Roger E Critchlow Jr, Cambridge, MA, USA.
# 
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
# 

#
# This is a reimplementation of gnome-mahjongg, my preferred time wasting
# solitaire on linux.  For many years I have been annoyed by aspects of
# gnome-mahjongg, but each attempt to deal with the code have been repelled
# by the density of the frameworks used to write the program.  I literally
# could not find the program in its source code, because most of the source
# code is somewhere else in a software framework.  So, I have rewritten 
# the program using Tcl, Tk, and Snit so that all of the source code will
# be apparent to anyone wishing to modify the program.
#
# I will provide only the barest introduction to Tcl, Tk, and Snit because
# you will need other resources if you really want to understand.  Start
# with the online manuals at https://www.tcl.tk/man/ and liberally apply
# google to your problems
#
# Tcl writes function calls in the form
#	func arg arg2
# the result of a function call is captured by square brackets 
#	[func arg arg2]
# variable references are written as
#	$variable
# variable assignment is performed by the set command
#	set variable {1 2 3}
# double quoted text is scanned for command and variable substitution
#	"substitutes $variable and [func arg arg2] in line"
# but curly brace quoted text
#	{does not evaluate $variable or [func arg arg2]}
# Memorizing https://www.tcl.tk/man/tcl8.6/TclCmd/Tcl.htm is a good plan.
#
# Tk uses Tcl to implement graphical user interfaces.  Originally a client 
# of the X11 windowing system on Unix, Tk now happily runs as a native client
# almost everywhere.  Tk user interface widgets are instances given names
#	canvas .name
# the instance name can then be used to set and retrieve configuratio options
#	.name configure -background blue
#	.name cget -background
# or to run methods
#	.name create image
# The manual pages for Tk and the widget-demo.tcl example script will give you
# an overview of the widgets implemented by Tk.  But Mahjong doesn't use much 
# of all that because it is entirely implemented in one Tk canvas widget.
#
# Snit uses Tcl to implement a Tk style object system.  Snit is distributed as
# part of Tcllib, a library implemented entirely in Tcl without use of extensions
# written in C or other high level languages.
#
package require Tcl
package require snit

snit::type mahjong::layout {
    option -verbose -default 1
    option -map -default {} -configuremethod Configure
    option -layout -readonly true
    option -slots -readonly true
    option -layers -readonly true
    option -rows -readonly true
    option -blocks -readonly true

    constructor {args} {
	if {$options(-verbose) > 5} { puts "$self configure $args" }
	$self configure {*}$args
    }

    # create the layout from a map
    method {Configure -map} {val} {
	if {$options(-verbose) > 5} { puts "$self configure -map $val" }
	set options(-map) $val
	set options(-layout) [dict create]
	set options(-slots) {}
	foreach layer $options(-map) {
	    $self expand-layout $layer
	}
	foreach slot $options(-slots) {
	    $self compute-x-adjacent $slot
	    $self compute-z-shadow $slot
	    #$self compute-left-and-right-rows $slot
	}
	foreach slot $options(-slots) {
	    $self compute-x-closure $slot
	    $self compute-row-closure $slot
	}

    }

    # maintaining slots in the layout
    # the options(-layout) dictionary maps xyz slots to properties
    method set {xyz tag val} { dict set options(-layout) $xyz $tag $val }
    method get {xyz tag} { return [dict get $options(-layout) $xyz $tag] }
    method exists {xyz tag} { return [dict exists $options(-layout) $xyz $tag] }
    method lappend {xyz tag args} { dict with options(-layout) $xyz { lappend $tag {*}$args } }

    # maintaining the primary slot in the layout
    # this is the only one that changes after the layout is setup
    method set-slot {slot val} { $self set $slot slot $val }
    method get-slot {slot} { return [$self get $slot slot] }
    method exists-slot {slot} { return [$self exists $slot slot] }
    method set-empty {slot} { $self set-slot $slot {} }
    method is-empty {slot} { return [expr {[$self get-slot $slot] eq {}}] }
    method is-endcap {xyz} { return [$self get $xyz endcap] }

    proc slot-x {slot} { return [lindex $slot 0] }
    proc slot-y {slot} { return [lindex $slot 1] }
    proc slot-z {slot} { return [lindex $slot 2] }

    # get all of the slots in render order
    # ie, those which are obscured are drawn before those which obscure
    method get-slots {} { return $options(-slots) }
    # find the slots in a z layer in render order
    method layer-slots {z} { return [lmap slot [$self get-slots] {expr {($z == [slot-z $slot]) ? $slot : [continue]}}] }

    # expand the layout map description
    method expand-layout {layout {z 0}} {
	if {$options(-verbose) > 5} { puts "$self expand-layout $layout" }
	set tag [lindex $layout 0]
	array set l [lrange $layout 1 end]
	if {[info exists l(z)]} { set z $l(z) }
	switch $tag {
	    layer {
		foreach p $l(parts) { $self expand-layout $p $z }
	    }
	    tile {
		set row [list [$self add-tile $l(x) $l(y) $z]]
		$self add-row $row
		$self add-block $row
	    }
	    row {
		set row {}
		for {set x $l(right)} {$x >= $l(left)} {set x [expr {$x-1}]} {
		    lappend row [$self add-tile $x $l(y) $z]
		}
		$self add-row $row
		$self add-block $row
	    }
	    block {
		set block {}
		for {set y $l(top)} {$y <= $l(bottom)} {set y [expr {$y+1}]} {
		    set row {}
		    for {set x $l(right)} {$x >= $l(left)} {set x [expr {$x-1}]} {
			lappend row [$self add-tile $x $y $z]
		    }
		    $self add-row $row
		    lappend block {*}$row
		}
		$self add-block $block
	    }
	    default { error "what is $layout doing in the map?" }
	}
    }

    # add the list of slots in a row
    method add-row {row} { foreach slot $row { $self set $slot row $row } }
    # add the list of slots in a block
    method add-block {block} { foreach slot $block { $self set $slot block $block } }
    # mark two cells as x-adjacents, should be x-adjacent, need x-left-adjacent and x-right-adjacent, too
    method add-x-adjacent {xyz xnynzn} { $self add-symmetric x-adjacent $xyz $xnynzn }
    # record a symmetric relation
    method add-symmetric {relation slot1 slot2} {
	# puts "$self add-symmetric $relation {$slot1} {$slot2}a"
	if {[lsearch [$self get $slot1 $relation] $slot2] < 0} {
	    $self lappend $slot1 $relation $slot2
	}
	if {[lsearch [$self get $slot2 $relation] $slot1] < 0} {
	    $self lappend $slot2 $relation $slot1
	}
	# puts "$relation {$slot1} is [$self get $slot1 $relation]"
	# puts "$relation {$slot2} is [$self get $slot2 $relation]"
    }
    # an antisymmetric relation
    method add-left-adjacent {slot1 slot2} {
	if {$slot2 ni [$self get $slot1 left-adjacent]} { $self lappend $slot1 left-adjacent $slot2 }
	if {$slot1 ni [$self get $slot2 right-adjacent]} { $self lappend $slot2 right-adjacent $slot1 }
    }
    method add-right-adjacent {slot1 slot2} { $self add-left-adjacent $slot2 $slot1 }
	
    # add a new tile to the layout
    method add-tile {x y z} {
	# canonicalize the coordinates
	# trouble with x, y in double vs integer as dictionary keys
	set x [expr {double($x)}]
	set y [expr {double($y)}]
	set z [expr {int($z)}]
	if {$options(-verbose) > 5} { puts "add-tile $x $y $z" }
	set xyz [list $x $y $z]
	# initialize slot
	$self set-slot $xyz {}
	foreach {tag val} {x-adjacent {} x-closure {} left-adjacent {} right-adjacent {} z-shadow {} endcap 0} {
	    $self set $xyz $tag $val
	}
	lappend options(-slots) $xyz
	return $xyz
    }

    # compute the x-adjacent set of the tile
    method compute-x-adjacent {xyz} {
	foreach {x y z} $xyz break
	foreach dx {-1 1} {
	    set xn [expr {$x+$dx}]
	    foreach dy {-0.5 0 0.5} {
		set yn [expr {$y+$dy}]
		if { ! [$self exists-slot [list $xn $yn $z]]} continue
		set xnynzn [list $xn $yn $z]
		$self add-x-adjacent $xyz $xnynzn
		if {$xn-$x < 0} {
		    $self add-left-adjacent $xyz $xnynzn
		} else {
		    $self add-right-adjacent $xyz $xnynzn
		}
	    }
	}
	if {[llength [$self left-adjacent $xyz]] == 0 || 
	    [llength [$self right-adjacent $xyz]] == 0} {
	    $self set $xyz endcap 1
	}
    }
    # find the z-shadow cast by this tile on the next layer
    method compute-z-shadow {xyz} {
	foreach {x y z} $xyz break
	set shadow {}
	if {$z > 0} {
	    set x0 [expr {$x-0.5}]
	    set x1 [expr {$x+0.5}]
	    set y0 [expr {$y-0.5}]
	    set y1 [expr {$y+0.5}]
	    foreach slot [$self layer-slots [expr {$z-1}]] {
		foreach {nx ny nz} $slot break
		if {(min($x1,$nx+0.5)-max($x0,$nx-0.5)) > 0 
		    && (min($y1,$ny+0.5)-max($y0,$ny-0.5)) > 0} {
		    lappend shadow $slot
		}
	    }
	}
	$self set $xyz z-shadow $shadow
    }
    method compute-x-closure {xyz} {
	$self set $xyz x-closure [$self compute-relation-closure $xyz x-adjacent]
    }
    method compute-relation-closure {xyz relation} {
	array set closure {}
	set level 1
	set closure($xyz) $level
	set found 1
	while {$found} {
	    set found 0
	    incr level
	    foreach slot [array names closure] {
		if {$closure($slot) != $level-1} continue
		foreach s [$self $relation $slot] {
		    if { ! [info exists closure($s)]} {
			incr found
			set closure($s) $level
		    }
		}
	    }
	}
	# unset closure($xyz)
	return [lsort -real -index 0 [array names closure]]
    }
    # compute the row closure of a slot
    method compute-row-closure {xyz} {
	set rclosure {}
	lappend rowclosure $xyz
	foreach lr {left right} {
	    set closure {}
	    for {set new [$self $lr-adjacent $xyz]} {[llength $new] > 0} {set new $nnew} {
		set nnew {}
		foreach slot $new {
		    if {[lsearch $closure $slot] < 0} {
			lappend closure $slot
			lappend nnew {*}[$self $lr-adjacent $slot]
		    }
		}
	    }
	    lappend rowclosure {*}$closure
	}
	$self set $xyz row-closure [lsort -real -index 0 [lsort -real -index 1 $rowclosure]]
    }

    # return the z-shadow of a slot
    method z-shadow {xyz} { return [$self get $xyz z-shadow] }
    # return the x-adjacent of a slot
    method x-adjacent {xyz} { return [$self get $xyz x-adjacent] }
    # return the x-adjacent closure of a slot
    method x-closure {xyz} { return [$self get $xyz x-closure] }
    # return the left x-adjacent
    method left-adjacent {xyz} { return [$self get $xyz left-adjacent] }
    # return the right x-adjacent
    method right-adjacent {xyz} { return [$self get $xyz right-adjacent] }
    # return the block of the slot
    method block {xyz} { return [$self get $xyz block] }
    # return the row of a slot
    method row {xyz} { return [$self get $xyz row] }
    # return the row closure of a slot
    method row-closure {xyz} { return [$self get $xyz row-closure] }

    # number of empty slots, all filled, or all empty
    method number-empty {slots} { return [tcl::mathop::+ {*}[lmap s $slots {$self is-empty $s}]] }
    method all-filled {slots} {	return [expr {[$self number-empty $slots] == 0}] }
    method all-empty {slots} { return [expr  {[$self number-empty $slots] == [llength $slots]}] }
    method any-filled {slots} { return [expr {[$self number-empty $slots] < [llength $slots]}] }
    # well known slot sets all filled or all empty
    method any-filled-x-adjacent {xyz} { return [$self any-filled [$self x-adjacent $xyz]] } 
    method all-filled-left-adjacent {xyz} { return [$self all-filled [$self left-adjacent $xyz]] }
    method all-filled-right-adjacent {xyz}  { return [$self all-filled [$self right-adjacent $xyz]] }
    method all-empty-left-adjacent {xyz} { return [$self all-empty [$self left-adjacent $xyz]] }
    method all-empty-right-adjacent {xyz}  { return [$self all-empty [$self right-adjacent $xyz]] }
    # can a slot be played
    method can-play {slot} {
	# cannot play an empty slot
	if {[$self is-empty $slot]} { return 0 }
	# cannot play if covered in z
	if {[$self is-covered-in-z $slot]} { return 0 }
	# cannot play if covered in x
	if {[$self is-covered-in-x $slot]} { return 0 }
	return 1
    }
    method is-covered-in-z {slot} {
	foreach s [$self layer-slots [expr {[slot-z $slot]+1}]] {
	    if { ! [$self is-empty $s] && $slot in [$self z-shadow $s]} {
		return 1
	    }
	}
	return 0
    }
    method is-covered-in-x {slot} {
	if {[$self is-endcap $slot]} { return 0 }
	if {[$self all-empty-left-adjacent $slot]} { return 0 }
	if {[$self all-empty-right-adjacent $slot]} { return 0 }
	return 1
    }
    # can a slot be unplayed
    method can-unplay {slot {donotblock {}}} {
	# cannot unplay a filled slot
	if { ! [$self is-empty $slot]} { return 0 }
	# cannot unplay a slot over an empty slot in z
	if {[$self covers-empty-in-z $slot]} { return 0 }
	# cannot unplay a slot over an empty slot in x
	if {[$self covers-empty-in-x $slot]} { return 0 }
	# if donotblock is present, do not play next to or over it
	if {$donotblock ne {}} {
	    # this is the last bug in the game generator, if you
	    # choose the two slots to unplay independently, then
	    # the second can block the first, to be a legal unplay
	    # you have to be able to play the slots in either order
	    if {[$self blocks-in $slot $donotblock]} { return 0 }
	}
	# that was the last bug, but there is another. it is possible to
	# unplay legal moves to a deadlock. so I need to look ahead to
	# choose the best unplayable, or somehow finesse the problem
	return 1;
    }
    #
    method covers-empty-in-z {slot} {
	return [tcl::mathop::+ {*}[lmap s [$self z-shadow $slot] {$self is-empty $s}]]
    }
    #
    method covers-empty-in-x {slot} {
	# Each x-adjacent-closure shall start in one compartment
	# there are ways that multiple seeds could start in 
	# different rows in the compartment and grow together
	# but the growth cannot cross a boundary between different 
	# numbers of rows except when the crossing into row(s) is(are)
	# completely covered by the crossing out of row(s)
	set x [$self x-closure $slot]
	set n [llength $x]
	set ne [tcl::mathop::+ {*}[lmap s $x {$self is-empty $s}]]
	# entirely empty, any slot will do
	if {$ne == $n} { return 0 }
	# one slot left, it will do
	if {$ne == 1} { return 0 }
	# if it is an endcap slot
	if {[$self is-endcap $slot]} {
	    # all neighbors filled, it will do else wait until they're filled
	    if {[$self all-filled [$self x-adjacent $slot]]} { return 0 } else { return 1 }
	}
	# this block is empty, but the closure is not empty
	if {[$self all-empty [$self block $slot]]} {
	    # if all our neighbors to one side are filled, then okay, else not
	    if {[$self all-filled-left-adjacent $slot] || [$self all-filled-right-adjacent $slot]} {
		return 0 } else { return 1 }
	}
	# this block is not empty
	# this row, and its extensions into adjoining blocks are all empty
	# this is the key, isn't it?
	if {[$self all-empty [$self row-closure $slot]]} {
	    # if we are in a block that contains filled slots
	    # but a row that is empty, then any slot in the row
	    # is acceptable, but only if the rows connected to this
	    # row in the closure are empty, too.
	    return 0
	} else {
	    # if we are in a row closure that contains filled slots
	    # then if we are adjacent to a filled slot, okay,
	    # else not okay
	    if {[$self all-filled-left-adjacent $slot]} {
		return 0
	    } elseif {[$self all-filled-right-adjacent $slot]} {
		return 0
	    } 
	    # elseif {[$self any-filled-x-adjacent $slot]} { 
		# okay, maybe if we're partially filled
	        # return 0
	    # }
	    return 1
	}
	error "failed to classify case"
    }
    # does slot $sl1 block in slot $sl2
    method blocks-in {sl1 sl2} {
	# sl1 is on top of sl2 and blocks it in
	if {$sl2 in [$self z-shadow $sl1]} {
	    return 1
	}
	# sl1 is not next to sl2
	if {$sl2 ni [$self x-adjacent $sl1]} {
	    return 0
	}
	# sl2 is free on the other side
	if {[$self is-endcap $sl2]} {
	    return 0
	}
	# sl1 is to the left of sl2
	if {$sl1 in [$self left-adjacent $sl2]} {
	    # and there is nothing to the right
	    return [expr { ! [$self all-empty-right-adjacent $sl2]}]
	}
	# sl1 is to the right of sl2
	# and there is nothing to the left
	return [expr { ! [$self all-empty-left-adjacent $sl2]}]
    }
}

#
# I currently render the tiles svg file into a png using inkscape. The svg renders into
# an image with two rows of 44 tiles each.  The top row contains the unselected images 
# and the bottom row the selected images.  The list initializing the -tiles option below
# gives the names of the tiles.
#
# This set of tile images includes a spare white dragon, one drawn with Ubuntu branding 
# and the other rendering as a blank white tile.  A complete game set includes four of 
# each tile except for the seasons and flowers bonus tiles, which are each a set of four
# as they come.
#
# The mahjong::tiles type runs inkscape to create an appropriately sized image and then
# splits the tile images out of the resulting png.  It would be better to generate the
# images without the use of inkscape.  A full set of game tile names are defined and the
# appropriate tile images are associated with each tile name.
#
snit::type mahjong::tiles {
    option -svg -readonly true
    option -png -readonly true
    option -width -readonly true
    option -height -readonly true
    option -image -readonly true
    option -keep -default 1 -readonly true
    option -tiles -readonly true -default {
	stone-1 stone-2 stone-3 stone-4 stone-5 stone-6 stone-7 stone-8 stone-9
	north   west    south   east    red     green
	number-1 number-2 number-3 number-4 number-5 number-6 number-7 number-8 number-9
	bamboo-1 bamboo-2 bamboo-3 bamboo-4 bamboo-5 bamboo-6 bamboo-7 bamboo-8 bamboo-9
	season-1 season-2 season-3 season-4 {}       flower-1 flower-2 flower-3 flower-4
	white
    }
    option -normal -readonly true
    option -select -readonly true

    variable map [dict create]

    constructor {args} {
	$self configure {*}$args

	set n [llength $options(-tiles)]
	set twid $options(-width)
	set thgt [expr {$twid*11/8}]
	set options(-height) $thgt

	if { ! [file exists $options(-png)]} {
	    # -e $png == export to png file $png
	    # -D == export drawing
	    # -d $dpi == export at $dpi dots per inch (but better overridden by -w $width)
	    # -w $width == export at width of $width pixels
	    # -y 0.0 == export with background set to transparent
	    # exec inkscape -e $options(-png) -D -w [expr {$n*$twid}] -y 0.0 $options(-svg)
	    exec ./svg-stuff -w [expr {$n*$twid}] $options(-svg) $options(-png)
	}

	set options(-image) [image create photo -file $options(-png)]
	if { ! $options(-keep)} { exec rm $png }
	set img $options(-image)
	set options(-normal) {}
	set options(-select) {}
	for {set i 0} {$i < $n} {incr i} {
	    set name [lindex $options(-tiles) $i]
	    if {$name ne {}} {
		switch -glob $name {
		    season-* - flower-* { set card 1 }
		    default { set card 4 }
		}
		set x1 [expr {$i*$twid}]
		set x2 [expr {$x1+$twid}]
		set y1 0
		set y2 [expr {$y1+$thgt}]
		set y3 [expr {$y2+$thgt}]
		set nor [image create photo]
		$nor copy $img -from $x1 $y1 $x2 $y2
		set sel [image create photo]
		$sel copy $img -from $x1 $y2 $x2 $y3
		for {set j 1} {$j <= $card} {incr j} {
		    set tname "$name#$j"
		    dict set map $tname name $name
		    dict set map $tname normal $nor
		    dict set map $tname select $sel
		    if {$card == 4} {
			dict set map $tname match $name
		    } else {
			dict set map $tname match [string range $name 0 end-2]
		    }
		}
	    }
	}
    }
    # tiles returns a complete tile set, list of name#instance
    method get-tiles {} { return [dict keys $map] }
    # normal returns the normal image for a tile
    method normal {name} { return [dict get $map $name normal] } 
    # select returns the selected image for a tile
    method select {name} { return [dict get $map $name select] } 
    # match tests if the first tile matches the second tile
    method match {name1 name2} { return [expr {[dict get $map $name1 match] eq [dict get $map $name2 match]}] }
}

snit::widgetadaptor mahjong::canvas {
    option -layout -readonly true
    option -tiles -readonly true
    option -items -readonly true
    option -shuffled-items -readonly true
    option -shuffled-slots -readonly true
    option -offsets -default {0 0} -readonly true
    option -trace false

    option -title mahjong
    option -game -default 0
    option -start-timer 0
    option -remaining-moves 0
    option -remaining-tiles 0
    
    component layout
    component tiles

    delegate option -width to tiles
    delegate option -height to tiles

    delegate method get-tiles to tiles
    delegate method match to tiles

    delegate method set-slot to layout
    delegate method set-empty to layout
    delegate method get-slot to layout
    delegate method get-slots to layout
    delegate method is-empty to layout
    delegate method is-endcap to layout
    delegate method z-shadow to layout
    delegate method x-adjacent to layout
    # delegate method x-closure to layout
    delegate method can-unplay to layout
    delegate method can-play to layout
    
    delegate option * to hull
    delegate method * to hull
    
    variable data [dict create]
    
    constructor {args} {
	installhull using ::canvas
	bind $win <Configure> [mymethod adjust-window]
	bind $win <Button-3> [list {*}[mymethod menu-popup] %W %x %y]
	$self configure {*}$args

	$self menu-build
	
	set layout $options(-layout)
	set tiles $options(-tiles)
	
	set twid [$self cget -width]
	set thgt [$self cget -height]
	
	foreach name [$self get-tiles] {
	    set it [$win create image 0 0 -anchor nw]
	    dict set data name-to-item $name $it
	    dict set data item-to-name $it $name
	    dict set data selected {}
	    $win itemconfigure $it -image [$self normal-image $it]
	    # puts "$it is $name $i"
	    lappend options(-items) $it
	}
	
	$self new-game [clock seconds]
    }
    
    method name-to-item {name} { return [dict get $data name-to-item $name] }
    method item-to-name {item} { return [dict get $data item-to-name $item] }
    method item-to-slot {item} { return [dict get $data item-to-slot $item] }
    method slot-to-item {slot} { return [$self get-slot $slot] }
    method slot-to-name {slot} { return [$self item-to-name [$self slot-to-item $slot]] }
    
    method normal-image {item} { return [$tiles normal [$self item-to-name $item]] }
    method select-image {item} { return [$tiles select [$self item-to-name $item]] }
    method blank-image {item} { return [$tiles normal white#1] }
    
    # context menu, button 3 or 2 on the background
    # with single character accelerators on the root window
    method menu-build {} {
	# popup menu
	menu .m -tearoff no
	foreach entry {
	    {command n {New Game} new-game}
	    {command o {Restart} restart-game}
	    {separator}
	    {command p {Pause} pause-game}
	    {command c {Continue} continue-game}
	    {separator}
	    {command h {Hint} hint}
	    {command u {Undo} undo}
	    {command r {Redo} redo}
	    {separator}
	    {hint m {Menu} menu-menu}
	    {command s {Scores} scores}
	    {command p {Preferences} preferences}
	    {command j {Help} help}
	    {separator}
	    {command d {Debug} debug}
	    {command b {By Name} by-name}
	    {separator}
	    {command q {Quit} quit}
	} {
	    foreach {entry accelerator label meth var} $entry break
	    switch $entry {
		separator {
		    .m add separator
		}
		command {
		    .m add command -accelerator $accelerator -label $label -command [mymethod $meth]
		    bind . <$accelerator> [list {*}[mymethod menu-protect] $label $meth]
		}
		checkbutton {
		    .m add checkbutton -accelerator $accelerator -label $label -variable [myvar $var]
		    bind . <$accelerator> [list {*}[mymethod menu-protect] $label $meth]
		}
		hint {
		    .m add command -accelerator $accelerator -label $label
		    bind . <$accelerator> [mymethod $meth]
		}
		default {
		    error "unexpected menu entry command $entry"
		}
	    }
	}
    }
    # popup the menu when we are over the background
    method menu-popup {w x y} {
	if {[$win find withtag current] eq {}}  { tk_popup .m $x $y }
    }
    # enable and disable lists of menu entries
    method menu-enable-disable {enable disable} {
	foreach label $enable { .m entryconfigure $label -state normal }
	foreach label $disable { .m entryconfigure $label -state disabled }
    }
    # protect an accelerator from calling the entry function when disabled
    method menu-protect {label meth} {
	if {[.m entrycget $label -state] eq {normal}} {
	    $self $meth
	}
    }
    
    ##
    ## menu functions
    ##
    method new-game {{game {}}} {
	$self setup $game
	while {[catch {$self restart} error]} {
	    if {$error eq {cannot unplay}} {
		# puts "$error\n$::errorInfo"
		set options(-shuffled-slots) [shuffle $options(-shuffled-slots)]
		puts "retrying new game"
	    } else {
		puts "$error\n$::errorInfo"
		set options(-shuffled-slots) [shuffle $options(-shuffled-slots)]
		puts "retrying new game"
	    }
	}
    }
    method restart-game {} { $self restart }
    method pause-game {} {
	dict set data paused true
	foreach item [$self get-items] { $win itemconfigure $item -image [$self normal-image [$self blank-image]] }
	$self menu-enable-disable {{Continue}} {{New Game} {Restart} {Pause} {Hint} {Undo} {Redo} {Scores} {Preferences} {Help}}
	# turn off selection?
    }
    method continue-game {} {
	$self menu-enable-disable {{New Game} {Restart} {Pause} {Hint} {Undo} {Redo} {Scores} {Preferences}} {{Continue}}
	foreach item  [$self get-items] { $win itemconfigure $item -image [$self normal-image $item] }
	dict set data paused false
    }
    method hint {} {}
    method undo {} { $self history-undo }
    method redo {} { $self history-redo }
    
    method menu-menu {} { $self menu-popup . 100 100 }
    
    method scores {} {}
    method preferences {} {}
    method debug {} { $self history-restore $options(-deal-history) }
    method by-name {} {
	toplevel .b
	wm title .b {By Name}
	grid [ttk::label .b.l -text {Choose game by name}] -row 1 -column 0 -columnspan 2 -sticky ew 
	grid [ttk::entry .b.e] -row 2 -column 0 -columnspan 2 -sticky ew
	.b.e insert end [format-game $options(-game)]
	grid [ttk::button .b.okay -text Okay -command [list {*}[mymethod by-name-finish] okay]] -row 3 -column 0 -sticky ew
	grid [ttk::button .b.cancel -text Cancel -command [list {*}[mymethod by-name-finish] cancel]] -row 3 -column 1 -sticky ew
	
    }
    method by-name-finish {how} {
	if {$how eq {okay}} { set options(-game) [scan-game [.b.e get]] }
	destroy .b
	$self new-game $options(-game)
    }
	
    method quit {} { destroy . }
    
    ##
    ## window display helpers
    ##
    method inverted-offsets {} {
	if {$options(-offsets) eq {}} { set options(-offsets) {0 0} }
	return [lmap a $options(-offsets) {expr {-$a}}]
    }
    
    # compute the xoff yoff that centers the current 
    method adjust-window {} {
	#$win move all {*}[$self inverted-offsets]
	foreach {x1 y1 x2 y2} [$win bbox all] break
	set w [winfo width $win]
	set h [winfo height $win]
	set xoff [expr {(($w-($x2-$x1))/2) - $x1}]
	set yoff [expr {(($h-($y2-$y1))/2) - $y1}]
	#$win move all $xoff $yoff
	set options(-offsets) [list $xoff $yoff]
    }
    
    
    ##
    ## game play helpers
    ##
    method get-items {} { return $options(-items) }
    
    proc shuffle {oldlist} {
	set n [llength $oldlist]
	set list $oldlist
	for {set i 0} {$i < $n} {incr i} {
	    set j [expr {$i+int(rand() * ($n-$i))}]
	    if {$i != $j} {
		set li [lindex $list $i]
		set lj [lindex $list $j]
		set list [lreplace [lreplace $list $j $j $li] $i $i $lj]
	    }
	}
	return $list
    }
    
    method sort-matching {items} {
 	set sort {}
 	while {[llength $items] > 0} {
 	    set it1 [lindex $items 0]
 	    set items [lrange $items 1 end]
 	    lappend sort $it1
 	    set n1 [$self item-to-name $it1]
 	    for {set i2 0} {$i2 < [llength $items]} {incr i2} {
 		set it2 [lindex $items $i2]
 		if {[$self match $n1 [$self item-to-name $it2]]} {
 		    lappend sort $it2
 		    set items [lreplace $items $i2 $i2]
 		    break
 		}
 	    }
 	}
 	# puts [lmap i $sort {$self item-to-name $i}]
 	return $sort
    }
    
    method raise-in-render-order {} {
	foreach slot [$self get-slots] {
	    $win raise [$layout get $slot slot]
	}
    }
    
    ##
    ## window title bar status
    ##
    method start-status {} {
	if { ! [dict exists $data status-started]} {
	    dict set data status-started [after 100 [list {*}[mymethod update-status]]]
	}
    }
    
    method update-status {} {
	set gname [format-game $options(-game)]
	if {$options(-start-timer) == 0} {
	    set elapsed 0
	} else {
	    set elapsed [expr {[clock seconds] - $options(-start-timer)}]
	}
	set elapsed [format {%d:%02d} [expr {$elapsed/60}] [expr {$elapsed%60}]]
	wm title . "$options(-title) - $gname - $elapsed - $options(-remaining-moves) moves, $options(-remaining-tiles) tiles"
	dict set data status-started [after 100 [list {*}[mymethod update-status]]]
    }
    
    method start-timer {} {
	if {$options(-start-timer) == 0} { set options(-start-timer) [clock seconds] }
    }
    
    method update-score {} {
	set options(-remaining-moves) [$self count-moves]
    }
    
    method count-moves {} {
	return [llength [$self find-moves]]
    }
    
    proc format-game {game} {
	while {$game != 0} {
	    set c [expr {$game%26}]
	    set game [expr {$game/26}]
	    lappend format [lindex {a b c d e f g h i j k l m n o p q r s t u v w x y z} $c]
	}
	return [join [lreverse $format] {}]
    }
    
    proc scan-game {game} {
	set n 0
	foreach c [split $game {}] {
	    set n [expr {$n*26+[lsearch {a b c d e f g h i j k l m n o p q r s t u v w x y z} $c]}]
	}
	return $n
    }
    
    ##
    ## history maintenance
    ##
    method history-empty {} {
	dict set data history [dict create {*}{
	    count 0
	    future 0
	    items {}
	}]
	dict with data history {
	    $self menu-enable-disable {} {Undo Redo}
	}
    }
    method history-save {} {
	dict with data history {
	    return [dict create count 0 future $future items [lreverse $items]]
	}
    }
    method history-restore {old} {
	$self clear-selected
	dict set data history $old
	dict with data history {
	    if {$count < $future} {
		$self menu-enable-disable {Undo Redo} {}
	    } else {
		$self menu-enable-disable {Undo} {Redo}
	    }
	}
    }
    method history-get-count {} { return [dict get $data history count] }
    method history-get-future {} { return [dict get $data history future] }
    method history-get-items {} { return [dict get $data history items] }
    method history-add {it1 sl1 it2 sl2} {
	$self clear-selected
	incr options(-remaining-tiles) -2
	dict with data history {
	    if {[llength $items] > $count} {
		set items [lrange $items 0 $count-1]
	    }
	    lappend items [list $it1 $sl1 $it2 $sl2]
	    incr count 1
	    set future $count
	    $self menu-enable-disable {Undo} {Redo}
	}
    }
    method history-undo {} {
	# step back
	$self clear-selected
	incr options(-remaining-tiles) 2
	dict with data history {
	    incr count -1
	    $self move-undo {*}[lindex $items $count]
	    if {$count > 0} {
		$self menu-enable-disable {Undo Redo} {}
	    } else {
		$self menu-enable-disable {Redo} {Undo}
	    }
	}
    }
    method history-redo {} {
	# step forward
	$self clear-selected
	incr options(-remaining-tiles) -2
	dict with data history {
	    $self move-redo {*}[lindex $items $count]
	    incr count 1
	    if {$count < $future} {
		$self menu-enable-disable {Undo Redo} {}
	    } else {
		$self menu-enable-disable {Undo} {Redo}
	    }
	}
    }
    
    ##
    ## these change whether we're unplaying or playing
    ##
    method move-undo {item1 slot1 item2 slot2} {
	# puts "move-undo $item1 $slot1 $item2 $slot2"
	$self place-tile $slot1 $item1
	$self place-tile $slot2 $item2
    }
    method move-redo {item1 slot1 item2 slot2} {
	# puts "move-redo $item1 $slot1 $item2 $slot2"
	$self unplace-tile $slot1 $item1
	$self unplace-tile $slot2 $item2
    }
    
    ##
    ## setup the next game
    ##
    method setup {{game {}}} {
	# set up for a new game which might be restarted
	# so, game number seeds random number generator, 
	# results in shuffle of -slots and -tiles
	# the optional $game may be supplying a game by name
	# or simply the time
	if {$game eq {}} { set game [clock seconds] }
	set options(-game) $game
	expr {srand($options(-game))}
	set options(-shuffled-slots) [shuffle [$self get-slots]]
	set options(-shuffled-items) [$self sort-matching [shuffle [$self get-items]]]
	$self start-status
    }
    
    ##
    ## start or restart the currently setup game
    ##
    method restart {} {
	# empty slots
	foreach slot [$self get-slots] { $self set-empty $slot }
	# reset images
	foreach item $options(-items) { $win itemconfigure $item -image [$self normal-image $item] }
	# clear selection
	$self clear-selected
	# empty history
	$self history-empty
	# reset timer
	set options(-start-timer) 0
	
	# pick matching pairs from available
	set items $options(-shuffled-items)
	set slots $options(-shuffled-slots)
	set moves {}
	
	while {[llength $items]} {
	    set options(-remaining-tiles) [expr {[llength $moves]/2}]
	    
	    ## choose the pair of matched items to play
	    # take first and second item in item list
	    foreach {it1 it2} $items break
	    set items [lrange $items 2 end]
	    
	    # take first open slot in slot list
	    set sl1 [$self find-can-unplay $slots]
	    set s1 [lsearch $slots $sl1]
	    set slots [lreplace $slots $s1 $s1]

	    # mark the slot as played
	    $self place-tile $sl1 $it1
	    
	    # take next open slot in slot list
	    # but avoid slots that block $sl1
	    set sl2 [$self find-can-unplay $slots $sl1]
	    set s2 [lsearch $slots $sl2]
	    set slots [lreplace $slots $s2 $s2]
	    
	    # put the second items in their slots
	    $self place-tile $sl2 $it2
	    
	    # make backwards history
	    lappend moves $it1 $sl1 $it2 $sl2
	}
	
	# make the history of the play
	$self history-empty
	foreach {it1 sl1 it2 sl2} $moves {
	    $self history-add $it1 $sl1 $it2 $sl2
	}
	# save the list of moves that needed to get done
	set options(-deal-history) [$self history-save]
	$self history-empty
	
	# run through history in play order
	# verify that each proposed unplay move
	# is infact a legal move
	foreach move [dict get $options(-deal-history) items] {
	    foreach {it1 sl1 it2 sl2} $move break
	    set n1 [$self item-to-name $it1]
	    set n2 [$self item-to-name $it2]
	    if { ! [$self can-play $sl1]} {
		puts "proposed move sl1 $sl1 cannot play"
		break
	    } elseif { ! [$self can-play $sl2]} {
		puts "proposed move sl2 $sl2 cannot play"
		break
	    } elseif { ! [$self match $n1 $n2]} {
		puts "proposed move mismatches $n1 and $n2"
		break
	    } else {
		# remove the tiles from play
		$self move-redo $it1 $sl1 $it2 $sl2
		# keep history
		$self history-add $it1 $sl1 $it2 $sl2
	    }
	}
	# if we went all the way through
	if {[$self history-get-count] == 72} {
	    # then undo everything
	    while {[$self history-get-count] > 0} {
		$self history-undo
	    }
	} else {
	    # highlight the problem
	    puts "$it1 {$sl1} $n1 and $it2 {$sl2} $n2 at move [$self history-get-count]"
	    $win itemconfigure $it1 -image [$self select-image $it1]
	    $win itemconfigure $it2 -image [$self select-image $it2]
	    update
	}
	# raise slots in render order
	$self raise-in-render-order
	
	# adjust window
	$self adjust-window
	
	# compute
	set options(-remaining-tiles) [llength $options(-items)]
	set options(-remaining-moves) [$self count-moves]
    }
    
    ##
    ## game play/unplay mechanics
    ##
    method find-slots-in-play {} {
	return [lmap s [$self get-slots] {expr {[$self is-empty $s]?[continue]:$s}}]
    }
    method find-moves {} {
	set moves {}
	set slots [$self find-slots-in-play]
	set slots [$self find-all-can-play $slots]
	for {set i 0} {$i < [llength $slots]} {incr i} {
	    set si [lindex $slots $i]
	    set ni [$self slot-to-name $si]
	    for {set j [expr {$i+1}]} {$j < [llength $slots]} {incr j} {
		set sj [lindex $slots $j]
		set nj [$self slot-to-name $sj]
		if {[$self match $ni $nj]} {
		    lappend moves [list $si $sj]
		}
	    }
	}
	return $moves
    }
    
    method find-match-index {it1 items} {
	set n1 [$self item-to-name $it1]
	set index 0
	foreach it2 $items {
	    if {[$self match $n1 [$self item-to-name $it2]]} {
		return $index
	    }
	    incr index
	}
	error "failed to find a matching tile to $n1"
    }
    
    method find-can-unplay {slots {donotblock {}}} {
	foreach slot $slots {
	    if {[$self can-unplay $slot $donotblock]} { return $slot }
	}
	error "cannot unplay"
    }
    method find-all-can-unplay {slots {donotblock {}}} {
	return [lmap slot $slots {
	    expr {[$self can-unplay $slot $donotblock] ? $slot : [continue]}
	}]
    }
    method find-can-play {slots} {
	foreach slot $slots {
	    if {[$self can-play $slot]} { return $slot }
	}
	error "cannot play"
    }
    method find-all-can-play {slots} {
	return [lmap slot $slots {
	    expr {[$self can-play $slot] ? $slot : [continue]}
	}]
    }
    
    method place-tile {xyz it} {
	set twid [$self cget -width]
	set thgt [$self cget -height]
	dict set data item-to-slot $it $xyz
	set xstep [expr {$twid/10}]
	set ystep [expr {$thgt/10}]
	set twid [expr {$twid-$xstep}]
	set thgt [expr {$thgt-$ystep}]
	$self set-slot $xyz $it; # this is where the tile gets added to the slots in play
	foreach {x y z} $xyz break
	set x [expr {(3.5+$x)*$twid + $z*$xstep}]
	set y [expr {(0.5+$y)*$thgt - $z*$ystep}]
	$win coords $it $x $y
	$win itemconfigure $it -image [$self normal-image $it] -state normal
	$win bind $it <Enter> [list {*}[mymethod enter] $it]
	$win bind $it <Leave> [list {*}[mymethod leave] $it]
	$self raise-in-render-order
    }
    
    method unplace-tile {xyz it} {
 	dict set data item-to-slot $it {}
	$self set-empty $xyz
 	$win coords $it 0 0
 	$win itemconfigure $it -image {} -state hidden
 	$win bind $it <Enter> {}
 	$win bind $it <Leave> {}
    }
    
    ##
    ## tile mouse event handlers
    ## mostly concerned with selected tile management
    ##
    method get-selected {} { return [dict get $data selected] }
    method is-selected {} { return [expr {[$self get-selected] ne {}}] }
    
    method clear-selected {} {
	if {[$self is-selected]} {
	    foreach {it xyz name} [$self get-selected] break
	    $win itemconfigure $it -image [$self normal-image $it]
	}
	dict set data selected {}
    }
    method set-selected {args} { 
	$self clear-selected
	if {$args ne {}} {
	    foreach {it xyz name} $args break
	    $win itemconfigure $it -image [$self select-image $it]
	}
	dict set data selected $args
    }
    
    method enter {it} { $win bind $it <Button-1> [list {*}[mymethod button] $it] }
    method leave {it} {	$win bind $it <Button-1> {} }
    
    method button {it1} {
	# if the tile is playable
	set xyz1 [$self item-to-slot $it1]
	set name1 [$self item-to-name $it1]
	if {[$self can-play $xyz1]} {
	    # if there's an already selected tile
	    if {[$self is-selected]} {
		# get the selected tile and clear the selection
		foreach {it2 xyz2 name2} [$self get-selected] break
		$self clear-selected
		# if it's the same tile
		if {$it1 == $it2} {
		    # just return, we've cancelled the selection
		    # and undone the selected image
		    return;
		}
		# if it's a match to the previously selected tile
		if {[$self match $name1 $name2]} {
		    # start counting time
		    $self start-timer
		    # remove the tiles from play
		    $self move-redo $it1 $xyz1 $it2 $xyz2
		    # keep history
		    $self history-add $it1 $xyz1 $it2 $xyz2
		    # keep score
		    after 0 [list {*}[mymethod update-score]]
		    return
		}
		# select the new tile in place of the old one
		$self set-selected $it1 $xyz1 $name1
	    } else {
		# just select the new tile
		$self set-selected $it1 $xyz1 $name1
	    }
	}
    }
}

#
# create the layout for the "difficult" map tiles, rows, blocks, layers
# each layer of z is drawn offset in x and y to make the tiles stack
# layout is 7 tiles tall in y, plus a bit for the z offset,
# and 11 tiles wide in x, add a tile for margins, so
# take minimum of (width / 12) and ((height / 8) / 1.375)
# (taking aspect h/w = 1.375)
# to decide how large to make the tiles
#
# furthermore, the tiles, rows, and blocks in each layer
# are laid out in render order, which wasn't true in the
# original xml file
#
set mymap {
    {
	layer z 0 parts {
	    {tile x 10 y 3}
	    
	    {block left 8.5 right 9.5 top 0.5 bottom 1.5}
	    {block left 8.0 right 9.0 top 2.5 bottom 3.5}
	    {block left 8.5 right 9.5 top 4.5 bottom 5.5}
	    
	    {row y 0 left 3 right 7}
	    {row y 1 left 2.5 right 7.5}
	    {block left 3.0 right 7.0 top 2.0 bottom 4.0}
	    {row y 5 left 2.5 right 7.5}
	    {row y 6 left 3 right 7}
	    
	    {block left 0.5 right 1.5 top 0.5 bottom 1.5}
	    {block left 1.0 right 2.0 top 2.5 bottom 3.5}
	    {block left 0.5 right 1.5 top 4.5 bottom 5.5}
	    
	    {tile x 0 y 3}
	}
    }
    {
	layer z 1 parts {
	    {tile x 6.5 y 0}
	    
	    {row left 7 right 9 y 1}
	    {block left 7.5 top 2 right 8.5 bottom 4}
	    {row left 7 right 9 y 5}
	    
	    {tile x 6.5 y 6}
	    
	    {row y 0.5 left 4.5 right 5.5}
	    {row y 1.5 left 4 right 6}
	    {block top 2.5 left 3.5 bottom 3.5 right 6.5}
	    {row y 4.5 left 4 right 6}
	    {row y 5.5 left 4.5 right 5.5}
	    
	    {tile x 3.5 y 0}
	    
	    {row left 1 right 3 y 1}
	    {block left 1.5 top 2 right 2.5 bottom 4}
	    {row left 1 right 3 y 5}
	    
	    {tile x 3.5 y 6}
	} 
    }
    {
	layer z 2 parts {
	    {row y 2 left 2.5 right 7.5}
	    {row y 3 left 2 right 8}
	    {row y 4 left 2.5 right 7.5}
	}
    }
    {
	layer z 3 parts {
	    {tile x 7.5 y 3}
	    {block left 3.5 right 6.5 top 2.5 bottom 3.5}
	    {tile x 2.5 y 3}
	}
    }
    {row z 4 left 4 right 6 y 3}
    {row z 5 left 4.5 right 5.5 y 3}
    {tile z 6 x 5 y 3}
}

# create the game window
# with the layout and 
# the tile images for the game
# this is a tile width that works at 2560x1700 
set width 165
pack [mahjong::canvas .c -background \#323657 \
	  -layout [mahjong::layout ::layout -map $mymap] \
	  -tiles [mahjong::tiles ::tiles -svg postmodern.svg -png postmodern-$width.png -width $width] \
	 ] -fill both -expand true
