#!/usr/bin/wish

#
# translate the svg defining the mahjong tile set
# into tk::canvas graphics so the tiles can be 
# generated at appropriate scale for whatever
# window is used
#

#
# read a whole file
#
proc read-file {file} {
    set fp [open $file]
    set d [read $fp]
    close $fp
    return $d
}

#
# translate an xml format document into a tcl list
#
proc xml2list xml {
    regsub -all {>\s*<} [string trim $xml " \n\t<>"] "\} \{" xml
    set xml [string map {> "\} \{#text \{" < "\}\} \{"}  $xml]

    set res ""   ;# string to collect the result   
    set stack {} ;# track open tags
    set rest {}

    foreach item "{$xml}" {
        switch -regexp -- $item {
            ^# {
		append res "{[lrange $item 0 end]} " ; #text item
	    }
	    ^/ {
                regexp {/(.+)} $item -> tagname ;# end tag
                set expected [lindex $stack end]
                if {$tagname!=$expected} {error "$item != $expected"}
                set stack [lrange $stack 0 end-1]
                append res "\}\} "
	    }
            /$ { # singleton - start and end in one <> group
                regexp {([^ ]+)( (.+))?/$} $item -> tagname - rest
                set rest [lrange [string map {= " "} $rest] 0 end]
                append res "{$tagname [list $rest] {}} "
            }
	    ^!-- { # comment
	    }
            default {
                set tagname [lindex $item 0] ;# start tag
                set rest [lrange [string map {= " "} $item] 1 end]
                lappend stack $tagname
                append res "\{$tagname [list $rest] \{"
            }
        }
        if {[llength $rest]%2} {error "att's not paired: $rest"}
    }
    if [llength $stack] {error "unresolved: $stack"}
    string map {"\} \}" "\}\}"} [lindex $res 0]
}

namespace eval svg {
    variable defs
    array set defs {}
    variable targets
    array set targets {}
    variable defsid {}
}
##
## interpret transforms
##
# is a 3 element row vector
proc svg::is-vector {v} {
    return [tcl::mathop::& [expr {[llength $v]==3}] {*}[lmap vi $v {string is double $vi}]]
}
# is a 3x3 matrix
proc svg::is-matrix {m} {
    return [tcl::mathop::& [expr {[llength $m]==3}] {*}[lmap mi $m {is-vector $mi}]]
}
# matrix(a b c d e f) as a matrix
proc svg::abcdef-to-matrix {abcdef} {
    if {[llength $abcdef] != 6} { error "bad abcdef: $abcdef" }
    foreach {a b c d e f} $abcdef break
    return [list [list $a $c $e] [list $b $d $f] {0 0 1}]
}
# scale(x y) as a matrix
proc svg::scale-to-abcdef {x {y {}}} {
    if {$y eq {}} { set y $x }
    return [list $x 0 0 $y 0 0]
}
# translate(x y) as a matrix
proc svg::translate-to-abcdef {x {y 0}} {
    return [list 1 0 0 1 $x $y]
}
proc svg::matrix-from-translate {x {y 0}} {
    return [abcdef-to-matrix [translate-to-abcdef $x $y]]
}
proc svg::matrix-from-scale {x {y {}}} {
    return [abcdef-to-matrix [scale-to-abcdef $x $y]]
}
# vector dot product between vectors written as rows
proc svg::vector-dot {v1 v2} {
    return [tcl::mathop::+ {*}[lmap x $v1 y $v2 {expr {$x*$y}}]]
}
# matrix transpose, only 3x3
proc svg::matrix-transpose {m} {
    foreach {r1 r2 r3} $m break
    return [lmap x1 $r1 x2 $r2 x3 $r3 {list $x1 $x2 $x3}]
}
# matrix times a matrix, each as a column of rows
proc svg::matrix-mul-matrix {m1 m2} {
    if { ! [is-matrix $m1]} { error "bad matrix: $m1" }
    if { ! [is-matrix $m2]} { error "bad matrix: $m2" }
    return [ lmap m1i $m1 { lmap m2j [matrix-transpose $m2] {vector-dot $m1i $m2j} }]
}
# matrix times a column vector written as a row
proc svg::matrix-mul-vector {m v} {
    return [ lmap mi $m {vector-dot $mi $v} ]
}
# matrix as matrix(a b c d e f)
proc svg::matrix-to-abcdef {matrix} {
    foreach {r1 r2 r3} $matrix break
    foreach {a c e} $r1 break
    foreach {b d f} $r2 break
    foreach {g h i} $r3 break
    if {$g != 0 || $h != 0 || $i != 1} { error "matrix has an unexpected third row {$matrix}" }
    return [list $a $b $c $d $e $f]
}
# 
proc svg::transform-interpret {tag attrs matrix} {
    # matrix(<a> <b> <c> <d> <e> <f>) -> [[a c e] [b d f] [0 0 1]]
    #	[xp]   [a c e]   [xn]
    #	[yp] = [b d f] * [yn]
    #	[ 1]   [0 0 1]   [ 1]
    # translate(<x> [<y>]) == matrix(1 0 0 1 x y) -> [[1 0 x][0 1 y][0 0 1]]
    #	missing <y> then y == 0
    # scale(<x> [<y>]) == matrix(x 0 0 y 0 0) -> [[x 0 0][0 y 0][0 0 1]]
    #	missing <y> then y == x
    # rotate(<a> [<x> <y>]) matrix(cos(a) sin(a) -sin(a) cos(a) 0 0)
    # skewX(<a>) matrix(1 0 tan(a) 1 0 0)
    # skewY(<a>) matrix(1 tan(a) 0 1 0 0)
    #
    # transform1 transform2 are combined by matrix-mul-matrix $transform1 $transform2 
    # the current transformation matrix is the combination of all transforms defined 
    # and it transforms coordinates in the current user coordinate frame into coordinates
    # in the view port coordinate frame.
    #
    array set a $attrs
    if {[info exists a(transform)]} {
	set tfm $a(transform)
	set tfm [string map {{,} { }} $tfm]
	set tfm [regsub -all {  +} $tfm { }]
	set tfm [string trim $tfm]
	while {$tfm ne {}} {
	    if {[regexp {([a-zA-Z]+)\(([-0-9. ]+)\)(.*)$} $tfm all op args rest]} {
		set n [llength $args]
		switch $op {
		    matrix {
			if {$n != 6} {
			    error "bad matrix $tfm"
			}
			set matrix2 [svg::abcdef-to-matrix $args]
			set nmatrix [svg::matrix-mul-matrix $matrix $matrix2]
			#puts "$matrix * matrix($args) -> $nmatrix"
			set matrix $nmatrix
		    }
		    translate {
			if {$n != 1 && $n != 2} {
			    error "bad translate $tfm"
			}
			set matrix2 [svg::abcdef-to-matrix [svg::translate-to-abcdef {*}$args]]
			set nmatrix [svg::matrix-mul-matrix $matrix $matrix2]
			#puts "$matrix * translate($args) -> $nmatrix"
			set matrix $nmatrix
		    }
		    scale {
			if {$n != 1 && $n != 2} {
			    error "bad scale $tfm"
			}
			set matrix2 [svg::abcdef-to-matrix [svg::scale-to-abcdef {*}$args]]
			set nmatrix [svg::matrix-mul-matrix $matrix $matrix2]
			#puts "$matrix * scale($args) -> $nmatrix"
			set matrix $nmatrix
		    }
		    rotate {
			if {$n < 1 || $n > 3} {
			    error "bad rotate $tfm"
			}
			set nmatrix [svg::matrix-mul-matrix $matrix [svg::rotate-to-matrix {*}$args]]
			puts "$matrix * rotate($args) -> $nmatrix"
			set matrix $nmatrix
		    }
		    skewX {
			if {$n != 1} {
			    error "bad skewX $tfm"
			}
			set nmatrix [svg::matrix-mul-matrix $matrix [svg::skewX-to-matrix {*}$args]]
			puts "$matrix * skewX($args) -> $nmatrix"
			set matrix $nmatrix
		    }
		    skewY {
			if {$n != 1} {
			    error "bad skewY $tfm"
			}
			set nmatrix [svg::matrix-mul-matrix $matrix [svg::skewY-to-matrix {*}$args]]
			puts "$matrix * skewY($args) -> $nmatrix"
			set matrix $nmatrix
		    }
		    default {
			error "unimplemented transform: $tfm"
		    }
		}
		set tfm [string trim $rest]
	    }
	}
    }
    return $matrix
}

namespace eval svg::path {}
#
# path d
# lower case relative, upper case absolute
# m or M = move
# l or L = line
# h or H = horizontal line
# v or V = vertical line
# c or C = cubic bezier 
# s or S = short cubic bezier
# q or Q = quartic bezier 
# t or T = short quartic bezier
# z or Z = terminate path
# a or A = elliptical arc
# numbers with optional spaces and commas
#

#
# this just parses all those wierdly concatenated operands into clean lists
# the additional interpretations available are:
#  1) rewrite h dx1 dx2 ... to l dx1 0 dx2 0 ...
#  2) rewrite v dy1 dy2 ... to l 0 dy1 0 dy2 ...
#  3) rewrite s dcx dcy dx dy ... into c ... by inserting the mirrored control point
#	(there are relatively few s operations in the tiles)
#  4) rewrite l concatenated to c by replicating the knot point as control point
#  5) rewrite m c* z as a smoothed canvas polygon
#  6) rewrite m c* (anything but z) as a smoothed canvas line
#	(there are very few of these in the tiles)
#
proc svg::path::parse {d} {
    set n [string length $d]
    set cmds {}
    set op {}
    set num {}
    set nums {}
    for {set i 0} {$i < $n} {incr i} {
	set c [string index $d $i]
	if {$c in {h H v V l L m M z Z c C q Q s S t T}} {
	    if {$num ne {}} { lappend nums $num; set num {} }
	    if {$op ne {}} { lappend cmds [list $op {*}$nums]; set nums {} }
	    set op $c; set num {}; set nums {}
	} elseif {$c eq {-}} { # negative sign, only as first character
	    if {$num ne {}} { lappend nums $num; set num {} }
	    append num $c
	} elseif {$c in {0 1 2 3 4 5 6 7 8 9 .}} { # part of a number
	    if { ! [string is double $num$c]} { lappend nums $num; set num {} }
	    append num $c
	} elseif {$c in {, { }}} { # comma or space, separator
	    if {$num ne {}} { lappend nums $num }
	    set num {}
	} else {
	    error "unexpected character {$c} in path.d"
	}
    }
    if {$num ne {}} { lappend nums $num; set num {} }
    if {$op ne {}} { lappend cmds [list $op {*}$nums]; set nums {} }
    return $cmds
}
proc svg::path::check-operands {cmds} {
    foreach cmd $cmds {
	set n [llength [lrange $cmd 1 end]]
	switch [lindex $cmd 0] {
	    m - M { set test {$n == 2} }
	    h - v -
	    H - V { set test {$n > 0} }
	    l - L { set test {$n > 1 && ($n % 2) == 0} }
	    s - S { set test {$n > 3 && ($n % 4) == 0} }
	    c - C { set test {$n > 5 && ($n % 6) == 0} }
	    z - Z { set test {$n == 0} }
	    default {
		error "unexpected command: $cmd"
	    }
	}
	if { ! [expr $test]} {
	    error "wrong number of arguments for: $cmd"
	}
    }
    return $cmds
}
proc svg::path::expand {cmds} {

    # translate from abbreviated commands to cubic beziers
    set lop {}
    set lxy {}
    set results {}
    foreach cmd $cmds {
	    set op [lindex $cmd 0]
	    set nresult [lrange $cmd 1 end]; # $result
	    while {1} {
		set result $nresult
		set nresult {}
		switch $op {
		    h { 
			foreach dx $result { lappend nresult $dx 0 }
			set op l
			continue
		    }
		    v {
			foreach dy $result { lappend nresult 0 $dy }
			set op l
			continue
		    }
		    l {
			# it seems that if the desired result is that the desired result
			# is a line from the last point of a cubic bezier, then the last
			# point in the bezier needs to be tripled, too, but because it's
			# relative coordinates, that will be 0 0 0 0 0 0.
			if {$lop eq {c}} { lappend nresult 0 0 0 0 0 0 }
			foreach {dx dy} $result { lappend nresult $dx $dy $dx $dy $dx $dy }
			set op c
			continue
		    }
		    s {
			# this is simplified by the change of coordinate frame.
			# ldc2x ldc2y and ldx ldy are specified relative to llx lly
			# so we can mirror ldcx ldcy through ldx ldy by subtraction,
			# oops, so the prior control point to be mirrored might be
			# in the c string immediately preceding this s string.
			if {$lop eq {c}} {
			    foreach {dc2x dc2y dx dy} [lrange $lxy end-3 end] break
			} elseif {$lop eq {m}} {
			    foreach {dc2x dc2y dx dy} [concat $lxy $lxy] break
			} else {
			    error "unexpected predecessor $lop to s in ..."
			}
			set dc1x [expr {$dx-$dc2x}]
			set dc1y [expr {$dy-$dc2y}]
			foreach {dc2x dc2y dx dy} $result {
			    lappend nresult $dc1x $dc1y $dc2x $dc2y $dx $dy
			    # compute next dc1x and dc1y
			    set dc1x [expr {$dx-$dc2x}]
			    set dc1y [expr {$dy-$dc2y}]
			}
			set op c
			continue
		    }
		    z {
			# close path, hmm, so the path ends c1 c2 k, 
			# but the k should be the same as the m that 
			# that started the path?  Looks like it usually
			# is the m that started the path
			# if {$lop eq {c} && $llop eq {m}} {
			#}
			break
		    }
		    m {
			# in a multi part path, this needs to be relative to
			# to the end of the previous path part, but maybe
			# that happens when we translate to coords from deltas.
		    }
		    c {
			break
		    }
		}
		break
	    }
	    if {$lop eq $op} {
		set lxy [list {*}$lxy {*}$result]
		set results [lreplace $results end end [list $lop {*}$lxy]]
	    } else {
		set lop $op
		set lxy $result
		lappend results [list $op {*}$lxy]
	    }

    }
    return $results
}
proc svg::path::translate-mc {xname yname cmd m c} {
    upvar $xname x
    upvar $yname y
    foreach {dx dy} [lrange $m 1 end] break
    set x [expr {$x+$dx}]
    set y [expr {$y+$dy}]
    lappend cmd $x $y
    foreach {dc1x dc1y dc2x dc2y dx dy} [lrange $c 1 end] {
	set c1x [expr {$x+$dc1x}]
	set c1y [expr {$y+$dc1y}]
	set c2x [expr {$x+$dc2x}]
	set c2y [expr {$y+$dc2y}]
	set nx [expr {$x+$dx}]
	set ny [expr {$y+$dy}]
	lappend cmd $c1x $c1y $c2x $c2y $nx $ny
	set x $nx
	set y $ny
    }
    return $cmd
}
proc svg::path::translate {results} {
    #
    # concatenate mcz and mc into canvas polygon and line items
    # translate from relative to absolute coordinates
    #
    # puts "path d [join [lmap r $results {lindex $r 0}] {}]"
    set cmds {}
    set type [join [lmap r $results {lindex $r 0}] {}];
    set x 0
    set y 0
    while {[llength $results] > 0} {
	switch -glob $type {
	    mcz* {
		lappend cmds [translate-mc x y {mcz} [lindex $results 0] [lindex $results 1]]
		set results [lrange $results 3 end]
		set type [string range $type 3 end]
	    }
	    mc* {
		lappend cmds [translate-mc x y {mc} [lindex $results 0] [lindex $results 1]]
		set results [lrange $results 2 end]
		set type [string range $type 2 end]
	    }
	    default {
		error "unexpected type $type"
	    }
	}
    }
    return $cmds
}
proc svg::path-interpret {d} {
    set cmds [svg::path::parse $d]
    set cmds [svg::path::check-operands $cmds]
    set cmds [svg::path::expand $cmds]
    return [svg::path::translate $cmds]
}

namespace eval svg::generate {}
#
# item generators
# oh, got the defs/use wrong
# need to do the translation 
# at the time of the call so
# that parameters supplied to
# the use can be expanded in
# the call.
#
proc svg::generate::emit {matrix code ctags} {
    if {[svg::in-defs $ctags]} {
	# set id [lindex $ctags $i+1]
	# puts "$ctags implies definition of $id"
	# lappend ::svg::defs($id) [list $matrix $code]
    } else {
	# puts "$ctags implies immediate code"
	lappend ::immed [list $matrix $code]
    }
}
proc svg::generate::frag-finish {matrix frag ctags} {
    if {[lsearch $frag -width] >= 0} { lappend ctags scale-width }
    lappend frag -tags $ctags
    emit $matrix $frag $ctags
}
proc svg::generate::line-finish {matrix frag fill stroke stroke-width ctags} {
    if {$stroke ne {}} { lappend frag -fill $stroke }
    if {${stroke-width} ne {}} { lappend frag -width ${stroke-width} }
    frag-finish $matrix $frag $ctags
}
proc svg::generate::poly-finish {matrix frag fill stroke stroke-width ctags} {
    if {$fill eq {none}} { set fill {} }
    lappend frag -fill $fill
    if {$stroke ne {}} { lappend frag -outline $stroke }
    if {${stroke-width} ne {}} { lappend frag -width ${stroke-width} }
    frag-finish $matrix $frag $ctags
}
proc svg::generate::path {matrix d fill stroke stroke-width ctags} {
    foreach cmd [svg::path-interpret $d] {
	set op [lindex $cmd 0]
	set coords [lrange $cmd 1 end]
	switch $op {
	    mcz { poly-finish $matrix [list .c create polygon {*}$coords -smooth raw] $fill $stroke ${stroke-width} $ctags }
	    mc { line-finish $matrix [list .c create line {*}$coords -smooth raw] $fill $stroke ${stroke-width} $ctags }
	    default { error "unknown op $op" }
	}
    }
}
proc svg::generate::polygon {matrix points fill stroke stroke-width ctags} {
    set frag [list .c create polygon {*}$points]
    poly-finish $matrix $frag $fill $stroke ${stroke-width} $ctags
}
proc svg::generate::line {matrix x1 y1 x2 y2 fill stroke stroke-width ctags} {
    set frag [list .c create line $x1 $y1 $x2 $y2]
    line-finish $matrix $frag $fill $stroke ${stroke-width} $ctags
}
proc svg::generate::rect {matrix x y width height fill stroke stroke-width ctags} {
    set frag [list .c create rectangle $x $y [expr {$x+$width}] [expr {$y+$height}]]
    poly-finish $matrix $frag $fill $stroke ${stroke-width} $ctags
}
proc svg::generate::circle {matrix cx cy r fill stroke stroke-width ctags} {
    set frag [list .c create oval [expr {$cx-$r}] [expr {$cy-$r}] [expr {$cx+$r}] [expr {$cy+$r}]]
    poly-finish $matrix $frag $fill $stroke ${stroke-width} $ctags
}
proc svg::generate::ellipse {matrix cx cy rx ry fill stroke stroke-width ctags} {
    set frag [list .c create oval [expr {$cx-$rx}] [expr {$cy-$ry}] [expr {$cx+$rx}] [expr {$cy+$ry}]]
    poly-finish $matrix $frag $fill $stroke ${stroke-width} $ctags
}
proc svg::generate::use {matrix pattrs id ctags} {
    # puts "use $matrix $id $ctags :: $::svg::defs($id)"
    if {[svg::in-defs $ctags]} {
	# when in defs section ignore the translation
    } else {
	# regenerate the code 
	foreach {indent c m p tag attrs body} $::svg::defs($id) break
	#if {{justdots} in $c} { 
	    #puts "svg::generate::use {matrix} {$pattrs} $id {ctags}"
	    #puts "   retrieved {c} {m} {p} $tag {$attrs} {body}"
	#}
	#set matrix [svg::matrix-mul-matrix $matrix $m]
	set pattrs [concat $p $pattrs]
	svg::element-traverse-one $indent $c $matrix $pattrs $tag $attrs $body
    }
}
#
# checkers
#
namespace eval ::svg {
    variable tags
    array set tags {
	svg {
	    ignore-all false
	    can-be-def false
	    require {height width viewBox} ignore {id xmlns:rdf xmlns version xmlns:cc xmlns:xlink xmlns:dc}
	    body-empty false
	}
	metadata {
	    ignore-all false
	    can-be-def false
	    ignore {id}
	    body-empty false
	}
	rdf:RDF	{
	    ignore-all false
	    can-be-def false
	    body-empty false
	}
	cc:Work {
	    ignore-all false
	    can-be-def false
	    ignore rdf:about
	    body-empty false
	}
	dc:format {
	    ignore-all false
	    can-be-def false
	    body-empty false
	}
	\#text {
	    ignore-all true
	}
	dc:type {
	    ignore-all false
	    can-be-def false
	    ignore {rdf:resource}
	    body-empty false
	}
	defs {
	    ignore-all false
	    can-be-def false
	    ignore {id}
	    body-empty false
	}
	g {
	    ignore-all false
	    can-be-def true
	    permit {transform style stroke stroke-width fill x y} ignore {id}
	    body-empty false
	    attr-filler {fill {} stroke {} stroke-width {}}
	}
	path {
	    ignore-all false
	    can-be-def true
	    require {d} permit {id fill stroke stroke-width style}
	    body-empty true
	    attr-filler {fill {} stroke {} stroke-width {}}
	}
	polygon {
	    ignore-all false
	    can-be-def true
	    require {points} permit {stroke stroke-width fill} ignore {id}
	    body-empty true
	    attr-filler {fill {} stroke {} stroke-width {}}
	}
	line {
	    ignore-all false
	    can-be-def true
	    require {x1 y1 x2 y2} permit {fill stroke stroke-width} ignore {id}
	    body-empty true
	    attr-filler {fill {} stroke {} stroke-width {}}
	}
	rect {
	    ignore-all false
	    can-be-def true
	    body-empty true
	    attr-filler {fill {} stroke {} stroke-width {}}
	    require {x y width height} permit {stroke stroke-width fill} ignore {id}
	}
	circle {
	    ignore-all false
	    can-be-def true
	    body-empty true
	    attr-filler {fill {} stroke {} stroke-width {}}
	    require {cx cy r} permit {stroke stroke-width fill} ignore {id}
	}
	ellipse {
	    ignore-all false
	    can-be-def true
	    body-empty true
	    attr-filler {fill {} stroke {} stroke-width {}}
	    require {cx cy rx ry} permit {stroke stroke-width fill} ignore {id}
	}
	use {
	    ignore-all false
	    can-be-def true
	    body-empty true
	    attr-filler {fill {} stroke {} stroke-width {}}
	    require {xlink:href} permit {transform style fill stroke stroke-width x y} ignore {id}
	}
    }
}

proc svg::tag-test {tag test} {
    variable tags
    array set info $tags($tag)
    return $info($test)
}
proc svg::ignore-all {tag} {
    return [tag-test $tag ignore-all]
}
proc svg::can-be-def {tag} {
    return [tag-test $tag can-be-def]
}
proc svg::attr-check {tag attributes} {
    variable tags
    array set info $tags($tag)
    array set b $attributes
    set missing {}
    foreach treatment {require permit ignore} {
	if { ! [info exists info($treatment)]} continue
	set attrs $info($treatment)
	foreach attr $attrs { 
	    set e [info exists b($attr)]
	    switch $treatment {
		require { if {$e} { unset b($attr) } else { lappend missing $attr } }
		permit { if {$e} { unset b($attr) } }
		ignore { if {$e} { unset b($attr) } }
		default { error "unknown attribute treatment: $treatment" }
	    }
	}
    }
    set leftovers [array names b]
    if {$missing ne {} || $leftovers ne {}} {
	error "attr-check $tag leftovers {$leftovers} missing {$missing}"
    }
}
proc svg::attr-filter {attrs} {
    set fattrs {}
    foreach {name value} $attrs {
	if {$name in {fill stroke stroke-width}} {
	    lappend fattrs $name $value
	}
    }
    return $fattrs
}
proc svg::body-empty {tag body} {
    if {[tag-test $tag body-empty] && $body ne {}} { 
	error "$tag body is not empty {$body}"
    }
}
proc svg::interesting-id {tag attrs} {
    array set a $attrs
    if { ! [info exists a(id)]} { return 0 }
    set id $a(id)
    if {[regexp ^$tag\\d+$ $id]} {
	#puts "$tag id=$id is uninteresting"
	return 0
    }
    if {$tag eq {path} && [regexp ^circle\\d+$ $id]} {
	#puts "$tag id=$id is uninteresting"
	return 0
    }
    if {[info exists ::svg::target($id)]} {
	error "$tag $id already defined as $::target($id)"
    }
    #puts "saving $tag $id"
    set ::target($id) $tag
    return 1
}
proc svg::interesting-target {tag attrs} {
    array set a $attrs
    if { ! [info exists a(xlink:href)]} { error "$tag has no href attribute" }
    set href $a(xlink:href)
    if {[string first \# $href] != 0} { error "$tag href $href does not start with #" }
    set href [string range $href 1 end]
    if { ! [info exists ::target($href)]} { error "$tag href $href is not defined" }
    return $href
}
proc svg::unpack-style {tag attrs} {
    array set a $attrs
    if {[info exists a(style)]} {
	switch -regexp $a(style) {
	    fill:#[0-9a-f]+ { return [list fill [string range $a(style) 5 end]] }
	    stroke:#[0-9a-f]+ { return [list stroke [string range $a(style) 7 end]] }
	    default { error "$tag unhandled style $a(style)" }
	}
    }
    return {}
}
proc svg::build-attrs {tag attrs pattrs} {
    array set info $svg::tags($tag)
    if {[info exists info(attr-filler)]} {
	array set a [concat $info(attr-filler) $pattrs $attrs]
	array set a [unpack-style $tag $attrs]
    } else {
	array set a $attrs
    }
    return [array get a]
}
		     
proc svg::lremove {list item} {
    set i [lsearch $list $item]
    if {$i >= 0} {
	set list [lreplace $list $i $i]
    }
    return $list
}
proc svg::in-defs {tags} {
    return [expr {$::svg::defsid ne {} && [lsearch $tags $::svg::defsid] >= 0}]
}

# traverse a document tree $doc
# using $indent as an indentation string
# and $ctags as the inherited canvas tags
# and $pattrs as the inherited attributes
proc svg::element-traverse {indent ctags matrix pattrs doc} {
    foreach {tag attrs body} $doc {
	element-traverse-one $indent $ctags $matrix $pattrs $tag $attrs $body
    }
}
proc svg::element-traverse-one {indent ctags matrix pattrs tag attrs body} {
    #element-setup $tag $attrs $body
    # if {$indent in {{} { } {  }}} { puts stdout "$indent$tag $attrs" }
    if {[ignore-all $tag]} return
    attr-check $tag $attrs
    body-empty $tag $body
    array set a [build-attrs $tag $attrs $pattrs]
    if {[info exists a(id)] && $a(id) ni $ctags} { lappend ctags $a(id) }
    if {[can-be-def $tag] && [interesting-id $tag $attrs]} {
	set ::svg::defs($a(id)) [list $indent [lremove $ctags $::svg::defsid] $matrix $pattrs $tag $attrs $body]
    }
    switch $tag {
	svg -
	metadata -
	rdf:RDF -
	cc:Work -
	dc:format -
	dc:type {}
	defs { 
	    set ::svg::defsid $a(id)
	}
	g {
	    set matrix [svg::transform-interpret $tag $attrs $matrix]
	    set pattrs [attr-filter [array get a]]
	}
	path {
	    svg::generate::path $matrix $a(d) $a(fill) $a(stroke) $a(stroke-width) $ctags
	}
	polygon {
	    svg::generate::polygon $matrix $a(points) $a(fill) $a(stroke) $a(stroke-width) $ctags
	}
	line {
	    svg::generate::line $matrix $a(x1) $a(y1) $a(x2) $a(y2) $a(fill) $a(stroke) $a(stroke-width) $ctags
	}
	rect {
	    svg::generate::rect $matrix $a(x) $a(y) $a(width) $a(height) $a(fill) $a(stroke) $a(stroke-width) $ctags
	}
	circle {
	    svg::generate::circle $matrix $a(cx) $a(cy) $a(r) $a(fill) $a(stroke) $a(stroke-width) $ctags
	}
	ellipse {
	    svg::generate::ellipse $matrix $a(cx) $a(cy) $a(rx) $a(ry) $a(fill) $a(stroke) $a(stroke-width) $ctags
	}
	use {
	    # call definition
	    set x 0; if {[info exists a(x)]} { set x $a(x) }
	    set y 0; if {[info exists a(y)]} { set y $a(y) }
	    set matrix [svg::transform-interpret $tag $attrs $matrix]
	    if {$x != 0 || $y != 0} {
		set matrix [matrix-mul-matrix $matrix [matrix-from-translate $x $y] ]
	    }
	    set id [interesting-target $tag $attrs]
	    svg::generate::use $matrix [attr-filter [array get a]] $id $ctags
	}
	default {
	    puts stderr "missing tag $tag"
	}
    }
    foreach item $body { element-traverse "$indent " $ctags $matrix $pattrs $item }
}
proc main {argv svg} {
    # get our rendering scale and translation
    # and the verbose settings
    foreach {s tx ty v} {1 0 0 0} break
    switch [llength $argv] {
	0 {  }
	1 { foreach {s} $argv break	}
	2 { foreach {s tx} $argv break }
	3 { foreach {s tx ty} $argv break }
	4 { foreach {s tx ty v} $argv break }
	default {
	    error {usage svg-stuff [scale [translate-x [translate-y [verbose]]]]}
	}
    }
    #set matrix [svg::abcdef-to-matrix [list $s 0 0 $s $tx $ty]]
    pack [canvas .c -width 2550 -height 400 -background  \#323657] -fill both -expand true
    bind .c <1> [list .c scan mark %x %y]
    bind .c <B1-Motion> [list .c scan dragto %x %y 1]
    svg::element-traverse {} {} [svg::abcdef-to-matrix {1 0 0 1 0 0}] {} [xml2list $svg]
    
    foreach record $::immed {
	foreach {matrix code} $record break
	set abcdef [svg::matrix-to-abcdef $matrix]
	set id [{*}$code]
	set xscale [lindex $abcdef 0]
	set yscale [lindex $abcdef 3]
	set xmove [lindex $abcdef 4]
	set ymove [lindex $abcdef 5]
	.c scale $id 0 0 $xscale $yscale
	.c move $id $xmove $ymove
	if {[lsearch [.c itemcget $id -tags] scale-width] >= 0} {
	    set width [.c itemcget $id -width]
	    .c itemconfigure $id -width [expr {$xscale*$width}]
	    # puts "$id [.c itemcget $id -tags] $width -> [expr {$xscale*$width}]"
	}
	#.c bind $id <Enter> [list puts "$id {[.c itemcget $id -tags]}"]
    }
    .c scale all 0 0 $s $s
    .c move all $tx $ty
    foreach id [.c find withtag scale-width] {
	set width [.c itemcget $id -width]
	.c itemconfigure $id -width [expr {$s*$width}]
	# puts "$id [.c itemcget $id -tags] $width -> [expr {$s*$width}]"
    }
}

main $argv [read-file postmodern.svg]
